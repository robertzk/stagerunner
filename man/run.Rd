% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stagerunner-run.R
\name{run}
\alias{run}
\title{Run the stages in a stageRunner object.}
\usage{
run(from = NULL, to = NULL, verbose = FALSE,
  remember_flag = getOption("stagerunner.remember", TRUE),
  mode = self$.mode, normalized = FALSE, .depth = 1, ...)
}
\arguments{
\item{from}{an indexing parameter. Many forms are accepted, but the
easiest is the name of the stage. For example, if we have
\code{stageRunner$new(context, list(stage_one = some_fn, stage_two = some_other_fn))}
then using \code{run('stage_one')} will execute \code{some_fn}.
Additional indexing forms are logical (which stages to execute),
numeric (which stages to execute by indices), negative (all but the
given stages), character (as above), and nested forms of these.
The latter refers to instances of the following:
\code{stageRunner$new(context, list(stage_one =
  stageRunner$new(context, substage_one = some_fn, substage_two = other_fn),
  stage_two = another_fn))}.
Here, the following all execute only substage_two:
\code{run(list(list(FALSE, TRUE), FALSE))},
\code{run(list(list(1, 2)))},
\code{run('stage_one/substage_two')},
\code{run('one/two')},
Notice that substrings are allowed for characters.
The default is \code{NULL}, which runs the whole sequences of stages.}

\item{to}{an indexing parameter. If \code{from} refers to a single stage,
attempt to run from that stage to this stage (or, if this one comes first,
this stage to that stage). For example, if we have
   \code{stages = list(a = list(b = 1, c = 2), d = 3, e = list(f = 4, g = 5))}
where the numbers are some functions, and we call \code{run} with
\code{from = 'a/c'} and \code{to = 'e/f'}, then we would execute
stages \code{"a/c", "d", "e/f"}.}

\item{verbose}{logical. Whether or not to display pretty colored text
informing about stage progress.
nested list of logicals.}

\item{remember_flag}{logical. An internal argument used by \code{run}
recursively if the \code{stageRunner} object has the \code{remember}
field set to \code{TRUE}. If \code{remember_flag} is FALSE, \code{run}
will not attempt to restore the context from cache (e.g., if we are
executing five stages simultaneously with \code{remember = TRUE},
the first stage's context should be restored from cache but none
of the remaining stages should).}

\item{mode}{character. If \code{mode = 'head'}, then by default the
\code{from} parameter will be used to execute that stage and that
stage only. If \code{mode = 'next'}, then the \code{from} parameter
will be used to run (by default, if \code{to} is left missing)
from the last successfully executed stage to the stage given by
\code{from}. If \code{from} occurs before the last successfully
executed stage (say S), the stages will be run from \code{from} to S.}

\item{normalized}{logical. A convenience recursion performance helper. If
\code{TRUE}, stageRunner will assume the \code{from} argument is a
nested list of logicals.}

\item{.depth}{integer. Internal parameter for keeping track of nested
execution depth.}

\item{...}{Any additional arguments to delegate to the \code{stageRunnerNode}
object that will execute its own \code{run} method.
(See \code{stageRunnerNode$run})}
}
\value{
TRUE or FALSE according as running the stages specified by the
  \code{from} and \code{to} keys succeeded or failed. If
  \code{remember = TRUE}, this will instead be a list of the environment
  before and after executing the aforementioned stages. (This allows
  comparing what changes were made to the \code{context} during the
  execution of the stageRunner.)
}
\description{
Run the stages in a stageRunner object.
}
\examples{
env <- new.env()
some_fn    <- function(e) e$x <- 1
other_fn   <- function(e) e$y <- 1
another_fn <- function(e) e$z <- 1
sr <- stagerunner(env, list(stage_one =
 stagerunner(env, list(substage_one = some_fn, substage_two = other_fn)),
 stage_two = another_fn))

# Here, the following all execute only substage_two:

sr$run(list(list(FALSE, TRUE), FALSE))
sr$run(list(list(1, 2)))
sr$run('stage_one/substage_two')
sr$run('one/two')
stopifnot(is.null(env$z), is.null(env$x), identical(env$y, 1))

# This will execute all but "stage_one" (i.e., only "stage_two")
sr$run(-1)
stopifnot(identical(env$z, 1))
}
