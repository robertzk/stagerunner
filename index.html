<!DOCTYPE html>
<html lang="en" class="">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta name="description" content="Stage Runner is an R package that helps with parametrizing and executing linear sequences of actions, common in the various stages of data analysis: data import, munging, modeling, export, and visualization.">

    <title>Parametrization and execution of linear sequences of actions</title>

    <link rel="stylesheet" media="all" href="stylesheets/rocco.css" />
    <link rel="stylesheet" media="all" href="stylesheets/github-markdown.css" />

    <script src="assets/highlight.pack.js"></script>
    <script type="text/javascript">
      hljs.initHighlightingOnLoad();
    </script>

    <style type="text/css">
      .header {
        position: fixed;
        top: 0px;
        width: 100%;
        background-color: rgba(0, 0, 0, 0.25);
        padding: 10px;
      }
      
      .header a {
        padding-right: 30px;
      }

      .container {
        margin-top: 40px;
      }

      body {
        padding: 0;
        margin: 0;
      }

      div.code-background {
        float: right;
        position: fixed;
        z-index: -1;
        height: 100%;
        background-color: #f8f8ff;
        width: 60%;
        right: 0px;
      }

      div.section {
        clear: both;
        margin: 0; padding: 0;
      }

      div.code {
        float: right;
        width: 60%;
      }

      code.R {
        font-size: 1.2em;
        line-height: 2em;
        margin-top: 0em;
        margin-bottom: -2em;
        padding-top: 0;
        margin-top: -1em;
      }

      code.R > span.spacer {
        position: relative;
      }

      div.code > pre {
        margin: 0;
        padding-left: 2em;
        margin-top: 0;
        margin-bottom: 0;
      }

      div.markdown {
        padding: 1em;
        padding-top: 0;
        background: #fff;
        float: left;
        width: 35%;
      }
    </style>

  </head>

  <body>
    <div class="header">
      <a href="https://github.com/robertzk/rocco">
        <img id="rocco-logo" src="https://img.shields.io/badge/Generated by rocco_v0.3.0-%E2%9C%93-blue.svg"/>
      </a>
    </div>
    <div class="container">

      <div class="code-background"></div>

        <div class="section">
          <div class="markdown markdown-body">
            <h1>boolean_fill.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>A stagerunner describes a <em>linear</em> sequence of execution: import data,
perform this munging step, then that munging, then do some modeling, etc.
However, it is structured hierarchically as a nested list for easier
usability. This function will create a nested list with the exact same
structure as the stagerunner except that each terminal node is either
<code>TRUE</code> or <code>FALSE</code>. </p>

<p>Specifically, given a tree structure with exactly one <code>TRUE</code> value in the
terminal nodes, all successors of that node will be marked as <code>TRUE</code>
as well. Conversely, if <code>forward = FALSE</code>, then all predecessors of
that node will be marked as <code>TRUE</code>.</p>

<p>For example, imagine we have a stagerunner with the following stages:</p>

<ul>
<li>import data</li>
<li>clean data

<ul>
<li>impute variable 1</li>
<li>discretize variable 2</li>
</ul></li>
<li>train model</li>
</ul>

<p>If <code>el</code>, the first argument to the <code>boolean_fill</code> function depicted on 
the right, refers to the &ldquo;impute variable 1&rdquo; stage, it will be represented
as <code>el = list(F, list(T, F), F)</code>.</p>

<ul>
<li>import data</li>
<li>clean data

<ul>
<li><strong>impute variable 1</strong></li>
<li>discretize variable 2</li>
</ul></li>
<li>train model</li>
</ul>

<p>Then calling the <code>boolean_fill</code> function depicted on the right with
<code>forward = TRUE</code> will signify we want to select the stages occuring
afterwards:</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"># The left panel will explain at a high level the code you see in this right panel.
# Scroll down to begin reading the code behind the stagerunner package.
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <ul>
<li>import data</li>
<li>clean data

<ul>
<li><strong>impute variable 1</strong></li>
<li><strong>discretize variable 2</strong></li>
</ul></li>
<li><strong>train model</strong></li>
</ul>

<p>The return value will be <code>list(F, list(T, T), T)</code>. If instead we
want the stages <em>before</em> &ldquo;impute variable 1&rdquo;, the return value
will be <code>list(T, list(T, F), F)</code>.</p>

<ul>
<li><strong>import data</strong></li>
<li><strong>clean data</strong>

<ul>
<li><strong>impute variable 1</strong></li>
<li>discretize variable 2</li>
</ul></li>
<li>train model</li>
</ul>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Fill a nested logical list with TRUEs before or after the first TRUE
#' 
#' This is a helper function to implement the \code{to} parameter
#' in the \code{run} method on a stageRunner object.
#'
#' @seealso \code{\link{run}}
#' @name boolean_fill
#' @param el list. A nested list of logicals with exactly one entry \code{TRUE}.
#' @param forward logical. \code{FALSE} for backwards, and \code{TRUE} for forwards.
#'   The default is \code{TRUE}.
#' @return the filled list
boolean_fill <- function(el, forward = TRUE) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We now dig into the actual code. The <code>!is.finite</code> condition on the right
works due to the behavior of <code>which</code>. If no element of the (possibly nested)
list <code>el</code> contains a <code>TRUE</code>, it will return a zero-length vector. When we 
subset to <code>[1]</code>, we get <code>NA</code>, which fails <code>is.finite</code>.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  ix <- which(vapply(el, contains_true, logical(1)))[1]
  if (!is.finite(ix)) stop("boolean_fill called but no TRUEs found")
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We could have checked that there is a <code>TRUE</code> somewhere in <code>el</code> more
elegantly, but we need the precise location, <code>ix</code>.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  if (isTRUE(forward)) {
    fills <- seq_len(length(el) - ix) + ix
  } else {
    fills <- seq_len(ix - 1)
  }
  el[fills] <- TRUE
  </span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>If the sequence of slots before or after the index which contains a <code>TRUE</code>
(according to the value of <code>forward</code>) have been flattened to a <code>TRUE</code> value,
the only remaining <code>TRUE</code> flattening has to occur recursively in any
remaining list elements.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  if (!is.atomic(el[[ix]])) {
    el[[ix]] <- boolean_fill(el[[ix]], forward = forward)
  }
  el
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>compare_stage_keys.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>A stagerunner is simply a linear sequence (of usually functions)
that is packaged as a tree structure to make it easier to reference
related groups of operations.</p>

<p>Since stagerunners are intended to be run sequentially, that is,
only backward to forwards rather than the other way around, it is
important to be able to identify when it is accidentally run
in the latter way. For example, if we have three stages and
a runner is called in the wrong order with <code>runner$run(2, 1)</code>,
we expect stage 1 to execute before stage 2.</p>

<p>The point of <code>compare_stage_keys</code> is to determine whether a later
stage has been called prior to an earlier stage. If that is
the case, this function will return <code>TRUE</code>, and later in the internals
of the stagerunner object we will be able to flip the keys.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Compare two stage keys to see which one has a stage run first
#' 
#' This is a helper function to implement the \code{to} parameter
#' in the \code{run} method on a stageRunner object.
#'
#' @seealso \code{\link{run}}
#' @name compare_stage_keys
#' @param key1 list
#' @param key2 list
#' @return logical. Whether or not key1 runs a stage before key2.
compare_stage_keys <- function(key1, key2) {
  if (length(key1) == 0 || isTRUE(key1)) return(TRUE)
  index_of_true <- function(el) which(vapply(el, contains_true, logical(1)))[1]</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p><code>ix</code> will be a vector of the location in the list structure of <code>key1</code> and
<code>key2</code> where the first (and, if they are correctly formed, the only)
<code>TRUE</code> occurs.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  ix <- vapply(list(key1, key2), index_of_true, numeric(1))
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>If no element in the first structure has a <code>TRUE</code>, the first key definitely
cannot run a stage first (since no stages have been marked for running!).</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  if (!is.finite(ix[1])) {
    return(FALSE)</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Otherwise, if the latter has no <code>TRUE</code>s, the first key definitely runs first.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  } else if (!is.finite(ix[2])) { return(TRUE) }

  if (ix[1] == ix[2]) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>If the keys specify the exact same stage in the stagerunner, there is
a tie and we may as well return TRUE.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    if (is.atomic(key1) && is.atomic(key2)) {
      TRUE
    } else {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Otherwise, one of the two keys must be another list, so we can 
recursively determine which key runs first.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">      compare_stage_keys(key1[[ix[1]]], key2[[ix[2]]])
    }</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We now come across a special case. Imagine we have
a stagerunner as before.</p>

<ul>
<li>import data</li>
<li>clean data

<ul>
<li>impute variable 1</li>
<li><strong>remove outliers from variable 1</strong></li>
<li><strong>discretize variable 2</strong></li>
</ul></li>
<li>train model</li>
</ul>

<p>If we call <code>runner$run(&quot;clean data/2&quot;, &quot;clean data&quot;)</code> this will signify
to &ldquo;run from &#39;remove outliers from variable 1&#39; to the end of the
&#39;clean data&#39; stage&rdquo; (i.e., until &ldquo;discretize variable 2&rdquo;).</p>

<p>However, note in this case that the two keys would be represented by
<code>list(F, list(F, T, T), F)</code> and <code>list(F, T, F)</code>. If we are not
careful, the <code>compare_stage_keys</code> function will indicate that
the latter occurs before the former, the keys will be flipped,
and we will end up executing &ldquo;impute variable 1&rdquo; instead!</p>

<ul>
<li>import data</li>
<li>clean data

<ul>
<li><strong>impute variable 1</strong> (the unintended effect)</li>
<li><strong>remove outliers from variable 1</strong></li>
<li>discretize variable 2</li>
</ul></li>
<li>train model</li>
</ul>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We solve this problem by returning <code>TRUE</code> if <code>key2</code> consists purely
of <code>TRUE</code>s (i.e., if it signifies &ldquo;run until the end of this stage&rdquo;).</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  } else if (all(vapply(key2, isTRUE, logical(1)))) {
    TRUE 
  } else { </span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Finally, if the keys are directly comparable, the first key should be run
earlier if and only if the first key contains a <code>TRUE</code> earlier than the
second key.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    ix[1] < ix[2]
  }
}

</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>copy_env.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Copy one environment into another recursively.
#' 
#' @param to environment. The new environment.
#' @param from environment. The old environment.
#' @note Both \code{to} and \code{from} must be pre-existing environments
#'   or this function will error.
copy_env <- function(to, from) {
  stopifnot(is.environment(to) && is.environment(from))
  rm(list = ls(to, all.names = TRUE), envir = to)
  for (name in ls(from, all.names = TRUE)) {
    if (is.environment(from[[name]])) {
      # Copy a sub-environment in full.
      assign(name, new.env(parent = parent.env(from[[name]])), envir = to) 
      copy_env(to[[name]], from[[name]])
    } else assign(name, from[[name]], envir = to)
  }
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>is_pre_stagerunner.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>The only way to turn an object into a stagerunner is if it can be
interpreted as a hierarchical sequence of execution: run some stuff
in group A, then run some stuff in group B, and so on, with each
group potentially containing more subgroups.</p>

<p>In other words, the things which can be turned into stagerunners
are:</p>

<ul>
<li>functions</li>
<li>other stagerunners (sub-stagerunners)</li>
<li>lists composed of the above</li>
</ul>

<p>The purpose of the <code>is_pre_stagerunner</code> function is to determine
whether an object satisfies these restrictions.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Whether or not an object can be transformed into a stageRunner.
#'
#' @param x ANY. An R object for which it will be determined whether or not
#'    it admits a conversion to a stageRunner.
#' @return TRUE or FALSE according to whether the object can be transformed
#'    to a stageRunner. In general, only a function or list of functions
#'    can be turned into a stageRunner.
#' @export
#' @examples
#' stopifnot(is_pre_stagerunner(function(e) { e$x <- 1 }))
#' stopifnot(is_pre_stagerunner(list(function(e) { e$x <- 1 }, function(e) { e$y <- 2 })))
#' stopifnot(is_pre_stagerunner(
#'   list(a = function(e) { e$x <- 1 },
#'     list(b = function(e) { e$y <- 2 }, c = function(e) { e$z <- 3 }))))
#' 
#' stopifnot(!is_pre_stagerunner(NULL))
#' stopifnot(!is_pre_stagerunner(5))
#' stopifnot(!is_pre_stagerunner(iris))
is_pre_stagerunner <- function(x) {
  if (is.function(x) || is.stagerunner(x)) { return(TRUE) }
  if (!is.recursive(x) || is.environment(x)) { return(FALSE) }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Using a for loop is a tiny bit faster than an apply-family operation
because we can exit the function early.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  for (i in seq_along(x)) {
    if (!(is.function(x[[i]]) || is.stagerunner(x[[i]]) || is.null(x[[i]]) ||</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We use the base function <a href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/Recall.html"><code>Recall</code></a>
for its recursive effect.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">          (is.recursive(x[[i]]) && Recall(x[[i]])))) {
      return(FALSE)
    }
  }

  TRUE
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>normalize_stage_keys.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>To determine what stages of a stagerunner to execute, we will use a nested
list format that is equivalent in structure to the runner. For example,
imagine we have a stagerunner with the following stages:</p>

<ul>
<li>import data</li>
<li>clean data

<ul>
<li>impute variable 1</li>
<li>discretize variable 2</li>
</ul></li>
<li>train model</li>
</ul>

<p>We would like to be able to execute swaths of this runner at will:
<code>runner$run(&quot;clean&quot;)</code>, <code>runner$run(&quot;clean/1&quot;, &quot;clean/2&quot;)</code> and 
<code>runner$run(2)</code> should all execute the data cleaning sub-stages.</p>

<p>The <code>normalize_stage_keys</code> function will convert human-readable
descriptions of what to execute, like <code>&quot;clean&quot;</code> or <code>2</code>, to a
nested list format that will be easier to use later during stage
execution.</p>

<p>For example, <code>&quot;clean/1&quot;</code> will be converted to
<code>list(F, list(T, F), F)</code> and mimic the structure of the stagerunner.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Normalize a reference to stage keys 
#'
#' For example, \code{list('data/one', 2)} would be converted to
#' \code{list('data', list('one')), 2)}.
#'
#' @name normalize_stage_keys
#' @param keys a list. The keys to normalize.
#' @param stages a list. The stages we're normalizing with respect to.
#' @param parent_key character. A helper for sane recursive error handling.
#'    For example, if we try to reference key \code{foo/bar}, but a recursive
#'    call to \code{normalize_stage_keys} errors when \code{bar} isn't found,
#'    we would still like the error to display the full name (\code{foo/bar}).
#' @param to an indexing parameter. If \code{keys} refers to a single stage,
#'   attempt to find all stages from that stage to this stage (or, if this one
#'   comes first, this stage to that stage). For example, if we have
#'      \code{stages = list(a = list(b = 1, c = 2), d = 3, e = list(f = 4, g = 5))}
#'   where the numbers are some functions, and we call \code{normalize_stage_keys}
#'   with \code{keys = 'a/c'} and \code{to = 'e/f'}, then we would obtain a nested
#'   list of logicals referencing \code{"a/c", "d", "e/f"}.
#' @return a list. The format is nested logicals. For example, if \code{stages} is
#'   \code{list(one = stageRunner$new(new.env(), list(subone = function(cx) 1)),
#'              two = function(cx) 1)}
#' then
#'   \code{normalize_stage_keys('one/subone')}
#' would return
#'   \code{list(one = list(subone = TRUE), two = FALSE)}.
#' @seealso stageRunner__run
#' @examples
#' \dontrun{
#'   stopifnot(identical(normalize_stage_keys("foo/bar",
#'     list(foo = list(bar = NULL, baz = NULL))),
#'     list(list(TRUE, FALSE))))
#' }
normalize_stage_keys <- function(keys, stages, to = NULL, parent_key = "") {
  if (is.null(to)) {
    normalize_stage_keys_unidirectional(keys, stages, parent_key)
  } else {
    normalize_stage_keys_bidirectional(keys, to, stages)
  }
}

normalize_stage_keys_unidirectional <- function(keys, stages, parent_key) {
  if (is.null(keys) || length(keys) == 0 || identical(keys, "")) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>By default, no key provided means to execute everything in this stage.
For single stages, that means <code>TRUE</code>. For multiple stages, a
list of <code>TRUE</code>s equal to the number of stages.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    return(if (!is.list(stages) || length(stages) == 1) TRUE
           else rep(list(TRUE), length(stages)))
  }</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Stagerunners are set up recursively, so we need to extract the <code>list</code> of
stages out of the stagerunner object. For example, </p>

<ul>
<li>import data</li>
<li>clean data

<ul>
<li>impute variable 1</li>
<li>discretize variable 2</li>
</ul></li>
</ul>

<p>actually consists of <em>two</em> stagerunners, one for the whole list and one
for the &ldquo;clean data&rdquo; stage.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  if (is.stagerunner(stages)) stages <- stages$stages
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>The output of <code>normalize_stage_keys</code> is a (possibly nested) list whose
terminal nodes are all logical. If <code>keys</code> is already of this format, we
are done.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  if (all_logical(keys)) return(keys) # Already normalized
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We performed checks for special cases, so now we call a function that
assumes all those cases have been taken care of. </p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  normalize_stage_keys_unidirectional_(keys, stages, parent_key)
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Our strategy to determine which stages to run, and thus translate <code>keys</code>
from a form like &ldquo;munge/impute variable 5&rdquo; to a nested list, will be to
start with a list of consisting entirely of <code>FALSE</code> and filling in the
sub-stages the user requested in the <code>keys</code> with <code>TRUE</code>s.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">normalize_stage_keys_unidirectional_ <- function(keys, stages, parent_key) {
  if (is.numeric(keys) && any(keys < 0)) { 
    as.list(!is.element(seq_len(stage_length(stages)), -keys))</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Negative indexing, like <code>-c(2:3)</code>, is easy: set everything <em>except</em> 
those keys to <code>TRUE</code>.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  } else {
    key_length      <- if (is.list(stages)) length(stages) else 1
    normalized_keys <- rep(list(FALSE), key_length)
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Each element of the provided keys has a chance to modify
<code>normalized_keys</code>. We achieve this using <a href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/funprog.html">Reduce</a>.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    Reduce(function(normalized_keys, index) {
      normalize_stage_keys_by_index(keys, stages, parent_key, index, normalized_keys)
    }, seq_along(keys), normalized_keys)
  }
}

normalize_stage_keys_by_index <- function(keys, stages, parent_key,
                                          key_index, normalized_keys) {
  key <- keys[[key_index]]

  rest_keys <- key[-1]
  key       <- key[[1]]
  
  normalize_stage_key(key = key, keys = rest_keys, stages = stages,
                      parent_key = parent_key, key_index = key_index,
                      normalized_keys = normalized_keys)
}

normalize_stage_key <- function(...) {
  UseMethod("normalize_stage_key")
}

normalize_stage_key.logical <- function(key, key_index, normalized_keys, ...) {
  #stop("!")
  normalized_keys[[key_index]] <- key
  normalized_keys
}

normalize_stage_key.numeric <- function(key, keys, stages, parent_key, 
                                        normalized_keys, ...) {
  stopifnot(length(key) == 1)
  if (key > stage_length(stages)) {
    stop(sprintf(
      "Cannot reference sub-stage %s of stage %s because it only has %d stages",
      sQuote(key), dQuote(parent_key), stage_length(stages)
    ))
  }

  normalized_keys[[as.integer(key)]] <-
    if (length(keys) == 0) TRUE
    else normalize_stage_keys(keys, stages[[as.integer(key)]],
                              parent_key = paste0(parent_key, key, '/'))
  normalized_keys
}

normalize_stage_key.character <- function(key, keys, stages, parent_key,
                                          normalized_keys, ...) {

  # The hard part! Allow things like one/subone/subsubone/etc
  # to reference arbitrarily nested stages.
  if (length(key) == 0) stop("Stage key of length zero")
  key <- strsplit(key, '/')[[1]]

  if (is.stageRunnerNode(stages)) {
    stop("No stage with key '", paste0(parent_key, key[[1]]), "' found")
  }

  key_index <- tolower(key[[1]]) == tolower(names(stages))
  if (!any(key_index)) {
    key_index <- grepl(tolower(key[[1]]), tolower(names(stages)))
  }

  if (is.finite(suppressWarnings(tmp <- as.numeric(key[[1]]))) &&
      tmp > 0 && tmp <= length(stages)) {
    key_index <- tmp
  } else if (length(key_index) == 0 || sum(key_index) == 0) {
    stop("No stage with key '", paste0(parent_key, key[[1]]), "' found")
  } else if (sum(key_index) > 1) {
    stop("Multiple stages with key '", paste0(parent_key, key[[1]]),
           "', found: ", paste0(parent_key, names(stages)[key_index], collapse = ', '))
  } else key_index <- which(key_index) # now an integer of length 1

  normalized_keys[[key_index]] <- special_or_lists(
    normalized_keys[[key_index]],
    normalize_stage_keys(append(paste0(key[-1], collapse = '/'), keys), 
      stages[[key_index]], parent_key = paste0(parent_key, key[[1]], '/'))
  )

  normalized_keys
}

normalize_stage_key.default <- function(...) {
  stop("Invalid stage key")
}

normalize_stage_keys_bidirectional <- function(from, to, stages) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>First, we turn our human-readable keys like &ldquo;clean/impute variable 1&rdquo;
into a more convenient list structure like <code>list(F, list(T, F, F), F)</code>.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  from <- normalize_stage_keys(from, stages)
  to   <- normalize_stage_keys(to, stages)</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Recall our helper <code>compare_stage_keys</code>, which returns <code>FALSE</code> if 
the first argument occurs before the second. In this situation, we
need to swap the keys.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  if (!compare_stage_keys(from, to)) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>A convenient swapping mechanism without introducing temporary variables.
In R, the <a href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/list2env.html"><code>list2env</code></a> utility
can funnel named values in a list directly into an environment.
Try it yourself:</p>

<pre><code class="r">x &lt;- 1
y &lt;- 2
list2env(list(x = y, y = x), environment())
cat(x, &quot;,&quot;, y)
</code></pre>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    list2env(list(from = to, to = from), environment())
  }</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>And finally the magic trick that pulls it all together. See the more
thorough explanation below beside the <code>special_and_lists</code> helper.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  special_and_lists(
    boolean_fill(from, forward = TRUE),
    boolean_fill(to,   forward = FALSE)
  )
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Terminal stages in a stagerunner are <code>stageRunnerNode</code> objects, so we treat
those as stages of length 1.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">stage_length <- function(obj) {
  if (is.list(obj)) length(obj)
  else 1
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>show_message.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Consider our example stagerunner from before:</p>

<ul>
<li>import data</li>
<li>clean data

<ul>
<li>impute variable 1</li>
<li>discretize variable 2</li>
</ul></li>
<li>train model</li>
</ul>

<p>Our goal is to display progress when executing the stagerunner:</p>

<p><img src="http://i.imgur.com/NKN3hnk.png" alt="runner"/></p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Show a progress message when executing a stagerunner.
#'
#' @name show_message
#' @param stage_names character.
#' @param stage_index integer.
#' @param begin logical. Whether we are showing the begin or end message.
#' @param nested logical. Whether or not this is a nested stage (i.e.
#'    contains another stageRunner).
#' @param depth integer. How many tabs to space by (for nested stages).
#' @return Nothing, but print the message to standard output.
#' @examples 
#' \dontrun{
#'   show_message(c('one', 'two'), 2) # Will print "Beginning one stage..."
#' }
show_message <- function(stage_names, stage_index, begin = TRUE,
                         nested = FALSE, depth = 1) {
  stage_name <- stage_names[stage_index]
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>If the stage was not named (i.e., only a function was given), we &ldquo;impute&rdquo;
the name with an ordinal: &ldquo;fifth&rdquo;, &ldquo;twelfth&rdquo;, &ldquo;21st&rdquo;, etc. (depending on
the index of the stage).</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  if (is.null(stage_name) || identical(stage_name, "") || identical(stage_name, NA_character_)) {
    stage_name <- as.ordinal(stage_index)
  }

  if (begin) {
    stage_name <- crayon::green(stage_name)
  } else {
    stage_name <- crayon::blue(stage_name)
  }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We indent by <code>depth</code> double-spaces to show nested stages clearly.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  prefix     <- paste(rep("  ", depth - 1), collapse = '')</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We turn &ldquo;import data&rdquo; into &ldquo;1. import data&rdquo;.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  stage_name <- paste0(stage_index, ". ", stage_name)
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Non-terminal stages (i.e., those with more sub-stages) have a beginning
and an ending, so we show &ldquo;Beginning 2. clean data stage&rdquo; and
&ldquo;Ending 2. clean data stage&rdquo;.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  if (nested) {
    cat(paste0(prefix, if (begin) "Beginn" else "End", "ing ",
               stage_name, " stage...\n"))
  } else if (begin) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Whereas terminal stages (i.e., those without sub-stages) just <em>run</em>,
so we show &ldquo;Running 1. import data stage&rdquo;.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    cat(paste0(prefix, "Running ", stage_name, "...\n"))
  }
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>special_and_lists.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Imagine we want to run from &ldquo;create validation set&rdquo; to &ldquo;create derived
variable.&rdquo;</p>

<ul>
<li>import data</li>
<li><strong>create validation set</strong></li>
<li><strong>munge data</strong>

<ul>
<li><strong>impute variable 1</strong></li>
<li><strong>create derived variable</strong></li>
<li>drop some variables</li>
</ul></li>
<li>train model</li>
</ul>

<p>The syntax for this is <code>runner$run(&quot;val&quot;, &quot;munge/derived&quot;)</code> (amongst
other ways &ndash; substrings are matched to stage names by the 
<code>normalize_stage_keys</code> helper).</p>

<p>To translate this into code, stagerunner builds the following two trees:</p>

<ul>
<li><code>FALSE</code></li>
<li><strong><code>TRUE</code></strong>

<ul>
<li><strong><code>TRUE</code></strong></li>
<li><strong><code>TRUE</code></strong></li>
<li><strong><code>TRUE</code></strong></li>
</ul></li>
<li><strong><code>TRUE</code></strong></li>
</ul>

<p>and</p>

<ul>
<li><strong><code>TRUE</code></strong></li>
<li><strong><code>TRUE</code></strong>

<ul>
<li><strong><code>TRUE</code></strong></li>
<li><strong><code>TRUE</code></strong></li>
<li><code>FALSE</code></li>
</ul></li>
<li><code>FALSE</code></li>
</ul>

<p>and then <em>intersects them</em>:</p>

<ul>
<li><code>FALSE</code></li>
<li><strong><code>TRUE</code></strong>

<ul>
<li><strong><code>TRUE</code></strong></li>
<li><strong><code>TRUE</code></strong></li>
<li><code>FALSE</code></li>
</ul></li>
<li><code>FALSE</code></li>
</ul>

<p>The point of <code>special_and_lists</code> is to perform this intersection operation.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' AND two lists together with some regards for nesting
#'
#' The structure of the lists should be the same. That is,
#' as a tree, the two lists should be isomorphic. For example,
#' \code{special_and_lists(list(a = FALSE, b = list(b = TRUE, c = FALSE)),
#'                         list(a = FALSE, b = list(b = FALSE, c = TRUE)))}
#' yields
#' \code{list(a = FALSE, b = list(b = FALSE, c = TRUE))}
#' and
#' \code{special_and_lists(list(a = FALSE, b = list(b = TRUE, c = FALSE)),
#'                         list(a = list(b = FALSE, c = TRUE), b = FALSE))}
#' yields
#' \code{list(a = list(b = FALSE, c = TRUE), b = list(b = TRUE, c = FALSE))}
#'
#' Note that lists get ANDed based on *order*, not on key names (as this could
#' be ambiguous), so make sure the two lists have the same comparable key orders.
#' For example, \code{special_and_lists(list(a = TRUE, b = FALSE), list(b = FALSE, a = TRUE))}
#' would mistakenly return \code{list(a = TRUE, b = TRUE)}.
#'
#' @name special_and_lists
#' @param list1 a list.
#' @param list2 a list.
#' @seealso \code{\link{special_or_lists}}
#' @return the and'ed list.
#' @examples \dontrun{
#'   stopifnot(identical(
#'     special_and_lists(list(a = FALSE, b = list(b = TRUE, c = FALSE)),
#'                       list(a = FALSE, b = list(b = FALSE, c = TRUE))),
#'     list(a = FALSE, b = list(b = FALSE, c = TRUE))
#'  ))
#' 
#'   stopifnot(identical(
#'     special_and_lists(list(a = FALSE, b = list(b = TRUE, c = FALSE)),
#'                       list(a = list(b = FALSE, c = TRUE), b = FALSE)),
#'     list(a = list(b = FALSE, c = TRUE), b = list(b = TRUE, c = FALSE))
#'  ))
#' }
special_and_lists <- function(list1, list2) {
  if (identical(list1, FALSE) || identical(list2, FALSE)) {
    FALSE</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>If one of the two lists is <code>TRUE</code>, an &ldquo;AND&rdquo; operation is simply
equivalent to choosing the other list.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  } else if (identical(list1, TRUE)) {
    list2
  } else if (identical(list2, TRUE)) {
    list1
  } else if (!(is.list(list1) && is.list(list2))) {
    stop("special_and_lists only accepts lists or atomic logicals of length 1")
  } else if (length(list1) != length(list2)) {
    stop("special_and_lists only accepts lists of the same length")
  } else {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>This function should only ever be used on lists coming from the same
hierarchy of stages, so give a warning if this is not the case.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    if (!identical(names(list1), names(list2))) {
      warning("special_and_lists matches lists by order, not name, ",
              "but the names of the two lists do not match!")
    }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We use <a href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/funprog.html">Map</a>
to recursively apply the operation to the remaining elements.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    Map(special_and_lists, list1, list2)
  }
}

</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>special_or_lists.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>This function is equivalent to <code>special_and_lists</code> but instead we apply 
&ldquo;OR&rdquo; to each pair of logical values:</p>

<ul>
<li><code>FALSE</code></li>
<li><strong><code>TRUE</code></strong>

<ul>
<li><strong><code>TRUE</code></strong></li>
<li><strong><code>TRUE</code></strong></li>
<li><code>FALSE</code></li>
</ul></li>
<li><code>FALSE</code></li>
</ul>

<p>and</p>

<ul>
<li><code>FALSE</code></li>
<li><code>FALSE</code>

<ul>
<li><code>FALSE</code></li>
<li><strong><code>TRUE</code></strong></li>
<li><strong><code>TRUE</code></strong></li>
</ul></li>
<li><code>FALSE</code></li>
</ul>

<p>would become</p>

<ul>
<li><code>FALSE</code></li>
<li><strong><code>TRUE</code></strong>

<ul>
<li><strong><code>TRUE</code></strong></li>
<li><strong><code>TRUE</code></strong></li>
<li><strong><code>TRUE</code></strong></li>
</ul></li>
<li><code>FALSE</code></li>
</ul>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' OR two lists together with some regards for nesting
#'
#' The structure of the lists should be the same. That is,
#' as a tree, the two lists should be isomorphic. For example,
#' \code{special_or_lists(list(a = FALSE, b = list(b = TRUE, c = FALSE)),
#'                         list(a = FALSE, b = list(b = FALSE, c = TRUE)))}
#' yields
#' \code{list(a = FALSE, b = list(b = TRUE, c = TRUE))}
#' and
#' \code{special_or_lists(list(a = FALSE, b = list(b = TRUE, c = FALSE)),
#'                         list(a = list(b = FALSE, c = TRUE), b = FALSE))}
#' yields
#' \code{list(a = list(b = FALSE, c = TRUE), b = list(b = TRUE, c = FALSE))}
#'
#' Note that lists get ORed based on *order*, not on key names (as this could
#' be ambiguous), so make sure the two lists have the same comparable key orders.
#' For example, \code{special_or_lists(list(a = TRUE, b = FALSE), list(b = FALSE, a = TRUE))}
#' would mistakenly return \code{list(a = TRUE, b = TRUE)}.
#'
#' @name special_or_lists
#' @param list1 a list.
#' @param list2 a list.
#' @seealso \code{\link{special_and_lists}}
#' @return the or'ed list.
special_or_lists <- function(list1, list2) {
  if (identical(list1, TRUE) || identical(list2, TRUE)) {
    TRUE
  } else if (identical(list1, FALSE)) {
    list2
  } else if (identical(list2, FALSE)) {
    list1
  } else if (!(is.list(list1) && is.list(list2))) {
    stop("special_or_lists only accepts lists or atomic logicals of length 1")
  } else if (length(list1) != length(list2)) {
    stop("special_or_lists only accepts lists of the same length")
  } else {
    if (!identical(names(list1), names(list2))) {
      warning("special_or_lists matches lists by order, not name, ",
              "but the names of the two lists do not match!")
    }
     
    Map(special_or_lists, list1, list2)
  }
}

</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner-append.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Imagine we have <em>two</em> stagerunners:</p>

<ul>
<li>Import data</li>
<li>Clean data</li>
</ul>

<p>and</p>

<ul>
<li>Train model</li>
<li>Export model</li>
</ul>

<p>It is a natural operation to <em>concatenate</em> or append these stagerunners
into a single runner. We can do this using the <code>$append</code> method.</p>

<p>However, append will create one final stage at the end instead of
juxtaposing the stages, to make it clear which runner was appended.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Append one stageRunner to the end of another.
#'
#' @name stageRunner_append
#' @param other_runner stageRunner. Another stageRunner to append to the current one.
#' @param label character. The label for the new stages (this will be the name of the
#'   newly appended list element).
stageRunner_append <- function(other_runner, label = NULL) {
  stopifnot(is.stagerunner(other_runner))
  new_stage <- structure(list(other_runner), names = label)</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Appending a stagerunner is simply concatenating its stages.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  self$stages <- c(self$stages, new_stage)
  self
}

</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner-around.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>The <code>around</code> method on a stagerunner is used as sort of <a href="http://stackoverflow.com/questions/6854658/explain-the-setup-and-teardown-methods-used-in-test-cases">setup and teardown</a>
hooks on arbitrary stages.</p>

<p>For example, imagine we have a stagerunner that looks like the following.</p>

<ul>
<li>import data</li>
<li>clean data

<ul>
<li>impute variable 1</li>
<li>discretize variable 2</li>
</ul></li>
</ul>

<p>Imagine we want to write test functions that ensure the correct behavior
is happening during the data cleaning. We can write a stagerunner with
an identical tree structure that performs additional testing to ensure
our work is correct:</p>

<pre><code class="r">new_runner &lt;- stageRunner$new(new.env(), list(
  &quot;import data&quot; = function(e) { yield(); stopifnot(!is.null(e$data)) },
  &quot;clean data&quot;  = list(
    &quot;impute variable 1&quot; = function(e) {
      yield()
      stopifnot(!any(is.na(e$data$variable1)))
    }, &quot;discretize variable 2&quot; = function(e) {
      yield()
      stopifnot(is.factor(e$data$variable2))
   })
))
</code></pre>

<p>The keyword <code>yield</code> is injected into a stagerunner that is used with the
<code>around</code> method, and means &ldquo;execute the stage of the stagerunner that is
being wrapped that would normally occur at this point.&rdquo; Code before
and after the <code>yield</code> keyword can be used to perform additional assertions
about what happened during the execution of the stage.</p>

<pre><code class="r">runner$around(new_runner)
runner$run()
</code></pre>

<p>If any of the above assertions fail, we will now get an error.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Wrap a function around a stageRunner's terminal nodes
#'
#' If we want to execute some behavior just before and just after executing
#' terminal nodes in a stageRunner, a solution without this method would be
#' to overlay two runners -- one before and one after. However, this is messy,
#' so this function is intended to replace this approach with just one function.
#'
#' Consider the runner
#'   \code{sr1 <- stageRunner$new(some_env, list(a = function(e) print('2')))}
#' If we run 
#'   \code{sr2 <- stageRunner$new(some_env, list(a = function(e) {
#'     print('1'); yield(); print('3') }))
#'    sr1$around(sr2)
#'    sr1$run()
#'  }
#' then we will see 1, 2, and 3 printed in succession. The \code{yield()}
#' keyword is used to specify when to execute the terminal node that
#' is sandwiched in the "around" runner.
#'
#' @name stageRunner_around
#' @param other_runner stageRunner. Another stageRunner from which to create
#'   an around procedure. Alternatively, we could give a function or a list
#'   of functions.
stageRunner_around <- function(other_runner) {
  if (is.null(other_runner)) return(self)
  if (!is.stagerunner(other_runner)) {
    # Create a new stagerunner if `other_runner` is not already a runner.
    other_runner <- stageRunner$new(self$.context, other_runner)
  }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>If no names are given <code>names(other_runner$stages)</code> may be <code>NULL</code>.
We would like a character vector of empty strings instead so may we
obtain the correct names in the loop below.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  stagenames <- names(other_runner$stages) %||% rep("", length(other_runner$stages))
  lapply(seq_along(other_runner$stages), function(stage_index) {
    name <- stagenames[stage_index]</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We assume each named stage has a unique name.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    # TODO: (RK) It may be possible to avoid this assumption by counting  
    # duplicately named stages.
    this_index <- 
      if (identical(name, "")) stage_index
      else if (is.element(name, names(self$stages))) name
      else return()
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>If both this stage and the corresponding stage on the other runner are
stagerunners, we recursively use the <code>around</code> method. Otherwise, we use
the <code>stageRunnerNode$around</code> method.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    if (is.stagerunner(self$stages[[this_index]]) &&
        is.stagerunner(other_runner$stages[[stage_index]])) {
      self$stages[[this_index]]$around(other_runner$stages[[stage_index]])
    } else if (is.stageRunnerNode(self$stages[[this_index]]) &&
               is.stageRunnerNode(other_runner$stages[[stage_index]])) {
      self$stages[[this_index]]$around(other_runner$stages[[stage_index]])
    } else {
      warning("Cannot apply stageRunner$around because ",
              this_index, " is not a terminal node.")
    }
  })
  self
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner-coalesce.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Coalescing two stagerunners is a critical operation for modifying a 
runner that is &ldquo;in flight&rdquo; and is currently being executed.</p>

<p>Imagine we have our usual example runner:</p>

<ul>
<li><strong>import data</strong></li>
<li><strong>clean data</strong>

<ul>
<li><strong>impute variable 1</strong></li>
<li>discretize variable 2</li>
</ul></li>
<li>train model</li>
</ul>

<p>It has <code>remember = TRUE</code>, which means it is keeping a copy of the 
current context in each stage. As in the example, we have executed it
to the imputation substage. We now realize there is a mistake in the
imputation code. We can re-create a new fresh stagerunner with the
same structure, but it will not have the history of context changes!</p>

<p>Instead, we must <em>coalesce</em> the old runner onto the new runner, so that it
carries over the environment changes. That way, when we continue execution
from the imputation substage in our fixed runner, it will resume as before
without having to re-import the data.</p>

<p>This can be inefficient for large datasets, but using the
<a href="http://github.com/robertzk/objectdiff">objectdiff</a> package we can avoid
the memory problems that may arise. For even larger datasets, we may need
database-backed storage, but this is beyond the scope of stagerunners for
now.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Coalescing a stageRunner object is taking another stageRunner object
#' with similar stage names and replacing the latter's cached environments
#' with the former's.
#'
#' @name stageRunner_coalesce
#' @param other_runner stageRunner. Another stageRunner from which to coalesce.
#' @note coalescing is ill-defined for stageRunner with unnamed stages,
#'    since it is impossible to tell when a stage has changed.
stageRunner_coalesce <- function(other_runner) {
  # TODO: Should we care about insertion of new stages causing cache wipes?
  # For now it seems like this would just be an annoyance.
  # stopifnot(remember)
  if (!isTRUE(self$remember)) return()
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We must handle these cases: (1) integration with 
<a href="http://github.com/robertzk/objectdiff">objectdiff</a>, and (2) vanilla
R environment objects. Both are tricky.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  if (self$with_tracked_environment()) {
    if (!other_runner$with_tracked_environment()) {
      stop("Cannot coalesce stageRunners using tracked_environments with ",
           "those using vanilla environments", call. = FALSE)
    }

    compare_head <- function(x, y) {
      m <- seq_len(min(length(x), length(y)))
      x[m] != y[m]
    }

    common <- sum(cumsum(compare_head(self$stage_names(), other_runner$stage_names())) == 0)
    # Warning: Coalescing stageRunners with tracked_environments does not
    # duplicate the tracked_environment, so the other_runner becomes invalidated,
    # and this is a destructive action.
    # TODO: (RK) What if the tracked_environment given initially to the stageRunner
    # already has some commits?
    commits     <- package_function("objectdiff", "commits")
    `.context<-` <- function(obj, value) {
      if (is.stagerunner(obj)) {
        obj$.context <- value
        for (stage in obj$stages) { Recall(stage, value) }
      } else if (is.stageRunnerNode(obj)) {
        obj$.context <- value
        if (is.stagerunner(obj$callable)) { Recall(obj$callable, value) }
      }
    }
    self$.context  <- other_runner$.context
    for (stage in self$stages) { .context(stage) <- other_runner$.context }</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Mark common executed stages.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    self_iterator  <- treeSkeleton(self)$root()$first_leaf()
    other_iterator <- treeSkeleton(other_runner)$root()$first_leaf()
    for (i in seq_along(common)) {
      self_iterator$object$executed <- other_iterator$object$executed
      self_iterator  <- self_iterator$successor()
      other_iterator <- other_iterator$successor()
    }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Coalescing is a destructive action since the other runner will no longer
be able to perform its function after the environments are moved.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    other_runner$.context <- new.env(parent = emptyenv())
    commit_count   <- length(commits(self$.context)) 
    mismatch_count <- commit_count - (common + 1)
    if (mismatch_count > 0) {
      package_function("objectdiff", "force_push")(self$.context, commit_count)
      package_function("objectdiff", "rollback")  (self$.context, mismatch_count)
    }
  } else {
    if (other_runner$with_tracked_environment()) {
      stop("Cannot coalesce stageRunners using vanilla environments with ",
           "those using tracked_environments", call. = FALSE)
    }

    stagenames <- names(other_runner$stages) %||% character(length(other_runner$stages))
    lapply(seq_along(other_runner$stages), function(stage_index) {
      # TODO: Match by name *OR* index
      if (stagenames[[stage_index]] %in% names(self$stages)) {
        # If both are stageRunners, try to coalesce our sub-stages.
        if (is.stagerunner(self$stages[[names(self$stages)[stage_index]]]) &&
            is.stagerunner(other_runner$stages[[stage_index]])) {
            self$stages[[names(self$stages)[stage_index]]]$coalesce(
              other_runner$stages[[stage_index]])
        # If both are not stageRunners, copy the cached_env if and only if
        # the stored function and its environment are identical
        } else if (!is.stagerunner(self$stages[[names(self$stages)[stage_index]]]) &&
            !is.stagerunner(other_runner$stages[[stage_index]]) &&
            !is.null(other_runner$stages[[stage_index]]$.cached_env) #&&
            #identical(deparse(stages[[names(stages)[stage_index]]]$fn),
            #          deparse(other_runner$stages[[stage_index]]$fn)) # &&
            # This is way too tricky and far beyond my abilities..
            #identical(stagerunner:::as.list.environment(environment(stages[[names(stages)[stage_index]]]$fn)),
            #          stagerunner:::as.list.environment(environment(other_runner$stages[[stage_index]]$fn)))
            ) {
          self$stages[[names(self$stages)[stage_index]]]$.cached_env <-
            new.env(parent = parent.env(self$.context))
          if (is.environment(other_runner$stages[[stage_index]]$.cached_env) &&
              is.environment(self$stages[[names(self$stages)[stage_index]]]$.cached_env)) {
            copy_env(self$stages[[names(self$stages)[stage_index]]]$.cached_env,
                     other_runner$stages[[stage_index]]$.cached_env)
            self$stages[[names(self$stages)[stage_index]]]$executed <- 
              other_runner$stages[[stage_index]]$executed
          }
        }
      }
    })
    self$.set_parents()
  }
  self
}

</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner-current_stage.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' This allows us to get the furthest executed stage.
#'
#' @name stageRunner_current_stage
#' @return a character stage key giving the latest executed stage.
#'   If the stageRunner does not have caching enabled, this will
#'   always return the first stage key (`'1'`).
stageRunner_current_stage <- function() {
  for (stage_index in rev(seq_along(self$stages))) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We use the <code>stageRunnerNode$was_executed</code> helper to determine if this
stage has been executed yet.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    is_executed_terminal_node <- is.stageRunnerNode(self$stages[[stage_index]]) &&
      self$stages[[stage_index]]$was_executed()

    if (is_executed_terminal_node) return(as.character(stage_index))
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We can recursively use <code>current_stage</code> if the current stage is another
stagerunner rather than a terminal node.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    has_executed_terminal_node <- is.stagerunner(self$stages[[stage_index]]) &&
      is.character(tmp <- self$stages[[stage_index]]$current_stage())

    if (has_executed_terminal_node) return(paste(c(stage_index, tmp), collapse = '/'))
  }
  FALSE
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner-has_key.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Whether or not the stageRunner has a key matching this input.
#'
#' @param key ANY. The potential key.
#' @return \code{TRUE} or \code{FALSE} accordingly.
stageRunner_has_key <- function(key) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We turn the key, like &ldquo;data/foo&rdquo; or <code>c(1,2)</code> into a
nested list of logicals in the usual format, or <code>FALSE</code> if
the key cannot be parsed.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  has <- tryCatch(normalize_stage_keys(key, self$stages),
                  error = function(.) FALSE)</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>If any substage is <code>TRUE</code>, the stagerunner contains this key.
Note that keys may refer to several different substages!
This method will tell us whether it is possible to execute anything
using the provided <code>key</code>.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  any(c(has, recursive = TRUE))
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner-initialize.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Initialize a stageRunner object.
#'
#' stageRunner objects are used for executing a linear sequence of
#' actions on a context (an environment). For example, if we have an
#' environment \code{e} containing \code{x = 1, y = 2}, then using
#' \code{stages = list(function(e) e$x <- e$x + 1, function(e) e$y <- e$y - e$x)}
#' will cause \code{x = 2, y = 0} after running the stages.
#'
#' @name stageRunner_initialize
#' @param context environment. The initial environment that is getting
#'    modified during the execution of the stages. 
#' @param stages list. The functions to execute on the \code{context}.
#' @param remember logical. Whether to keep a copy of the context and its
#'    contents throughout each stage for debugging purposes--this makes it
#'    easy to go back and investigate a stage.
#'    
#'    The default is \code{FALSE}. When set to \code{TRUE}, the return value
#'    of the \code{run} method will be a list of two environments: one of what
#'    the context looked like before the \code{run} call, and another
#'    of the aftermath.</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>When a stagerunner object is initialized, it needs to convert a
pre-stagerunner, like</p>

<pre><code class="r">list(first = some_function, second = list(
  sub1 = another_function, sub2 = a_third_function
)
</code></pre>

<p>into a stagerunner object. This class constructor will turn the above
into a hierarchy of stagerunners to make it easier to recursively
re-use functionality.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' @param mode character. Controls the default behavior of calling the
#'    \code{run} method for this stageRunner. The two supported options are
#'    "head" and "next". The former gives a stageRunner which always begins
#'    from the first stage if the \code{from} parameter to the \code{run}
#'    method is blank. Otherwise, it will begin from the previous unexecuted
#'    stage. The default is "head". This argument has no effect if
#'    \code{remember = FALSE}.
stagerunner_initialize <- function(context, stages, remember = FALSE,
                                   mode = getOption("stagerunner.mode") %||% "head") {
  </span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>As a convenient shortcut, if a stagerunner is initialized without a second
argument but with a first argument that can be turned into stages, we 
create a new environment for the context.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  if (missing(stages) && !missing(context) && is_pre_stagerunner(context)) {
    stages  <- context</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>The only parent environment that makes sense is the calling environment.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    context <- new.env(parent = parent.frame())
  }

  if (identical(remember, FALSE) && is(context, "tracked_environment")) {
    stop("Can not use tracked environments with stagerunners that have caching ",
         "disabled (remember = FALSE)")
  }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>The <code>enforce_type</code> helper in utils.R will print a nice and colorful error
message if we have initialized our stagerunner with the wrong argument
types.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  enforce_type(context,  "environment", "stagerunner", "context")
  enforce_type(remember, "logical",     "stagerunner", "remember")
  enforce_type(mode,     "character",   "stagerunner", "mode")
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p><a href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/match.arg.html"><code>match.arg</code></a>
is a convenient base R helper that will error unless one of a given set of
options is chosen.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  match.arg(mode, c("head", "next"))

  stopifnot(length(remember) == 1)

  self$.parent   <- NULL
  # The .finished flag is used for certain features when printing a stagerunner.
  self$.finished <- FALSE 
  self$.context  <- context
  self$.mode     <- tolower(mode)
  self$remember  <- remember
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>A stagerunner will recursively be represented using more stagerunners.
This way, we can re-use methods defined on a stagerunner on local 
subsections.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  self$stages    <- initialize_stages(stages, context, remember)
  </span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We wrap up with some messy initialization in case our stagerunner
intends to remember progress.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  if (isTRUE(self$remember)) {
    initialize_remembrance(self)
  }
}

initialize_stages <- function(stages, context, remember) {
  if (length(stages) == 0) {
    warning("stagerunners with zero stages may cause problems.")
  }

  if (!is_pre_stagerunner(stages)) {
    stop("Can only turn a function or list of functions into a stagerunner.")
  }

  if (is.function(stages)) {
    stages <- list(stages)
  }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>A loop is slightly faster than an <code>lapply</code> here.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  for (i in seq_along(stages)) {
    if (is.list(stages[[i]])) {
      stages[[i]] <- stagerunner(context, stages[[i]], remember = remember)
    } else if (is.function(stages[[i]]) || is.null(stages[[i]])) {
      stages[[i]] <- stageRunnerNode(stages[[i]], context)
    }
  }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We will be using the <code>/</code> character in a special way for running 
stages. For example, if we had a runner such as </p>

<ul>
<li>import data</li>
<li>clean data

<ul>
<li>impute variable 1</li>
<li>discretize variable 2</li>
</ul></li>
</ul>

<p>we would run the first substage using <code>runner$run(&quot;clean data/impute variable 1&quot;)</code>.
To avoid complications, we prevent the use of slashes in the stage names.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  prevent_stage_name_violators(stages)

  stages
}

prevent_stage_name_violators <- function(stages) {
  if (any(violators <- grepl("/", names(stages), fixed = TRUE))) {
    stop(paste0("Stage names may not have a '/' character. The following do not ",
      "satisfy this constraint: '",
      paste0(names(stages)[violators], collapse = "', '"), "'"))
  }
}

initialize_remembrance <- function(stagerunner) {
  stagerunner$.clear_cache()</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We set up some meta-data that will be used to track the 
changes occuring in the stagerunner. See the <code>treeSkeleton</code> class
later for more details.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  stagerunner$.set_parents()
  if (stagerunner$with_tracked_environment()) {
    stagerunner$.set_prefixes()
  } else if (length(stagerunner$stages) > 0) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>The very first stage should remember what the context looked like
upon initialization. After all, if a user messed with the context
and later re-runs the stagerunner from scratch, it should remember
what the context looked like <em>at the time of initialization</em>.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    first_env <- treeSkeleton$new(stagerunner$stages[[1]])$first_leaf()$object
    first_env$.cached_env <- new.env(parent = parent.env(stagerunner$.context))
    copy_env(first_env$.cached_env, stagerunner$.context)
  }
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner-internal.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>This file contains some messy internal methods that are necessary
for correct interoperation with the <code>treeSkeleton</code> class and
the <a href="http://github.com/robertzk/objectdiff">objectdiff</a> package.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Clear all caches in this stageRunner, and recursively.
#' @name stageRunner_.clear_cache
stageRunner_.clear_cache <- function() {
  for (i in seq_along(self$stages)) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>The stagerunner context just prior to stage execution is stored
in an environment cache. We clear this cache recursively.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    if (is.stagerunner(self$stages[[i]])) self$stages[[i]]$.clear_cache()
    else self$stages[[i]]$.cached_env <- NULL
  }
  TRUE
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>The <code>treeSkeleton</code> requires a recursive structure to be annotated with
&ldquo;parent metadata&rdquo; so it can be traversed like a tree structure. This is
what allows us to go from stage &ldquo;2/2&rdquo; to stage &ldquo;3&rdquo;, for example: we
are finding the successor node in the tree structure and &ldquo;running&rdquo; it.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Set all parents for this stageRunner, and recursively
#' @name stageRunner_.set_parents
stageRunner_.set_parents <- function() {
  for (i in seq_along(self$stages)) {
    # Set convenience helper attribute "child_index" to ensure that treeSkeleton
    # can find this stage.</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>The metadata required by the <code>treeSkeleton</code> class.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    attr(self$stages[[i]], 'child_index') <<- i
    attr(self$stages[[i]], 'parent') <<- self
  }
  self$.parent <- NULL
}

#' Get an environment representing the context directly before executing a given stage.
#'
#' @note If there is a lot of data in the remembered environment, this function
#'   may be computationally expensive as it has to create a new environment
#'   with a copy of all the relevant data.
#' @param stage_index integer. The substage for which to grab the before
#'   environment.
#' @return a fresh new environment representing what would have been in
#'   the context as of right before the execution of that substage.
stageRunner_.before_env <- function(stage_index) {
  cannot_run_error <- function() {
    stop("Cannot run this stage yet because some previous stages have ",
         "not been executed.")
  }

  if (self$with_tracked_environment()) {
    # We are using the objectdiff package and its tracked_environment,
    # so we have to "roll back" to a previous commit.
    current_commit <- paste0(self$.prefix, stage_index)

    if (!current_commit %in% names(package_function("objectdiff", "commits")(self$.context))) {
      if (`first_commit?`(current_commit)) {
        # TODO: (RK) Do this more robustly. This will fail if there is a 
        # first sub-stageRunner with an empty list as its stages.
        package_function("objectdiff", "commit")(self$.context, current_commit)
      } else {
        cannot_run_error()
      }
    } else {
      package_function("objectdiff", "force_push")(self$.context, current_commit)
    }

    env <- new.env(parent = package_function("objectdiff", "parent.env.tracked_environment")(self$.context))
    copy_env(env, package_function("objectdiff", "environment")(self$.context))
    env
  } else {
    env <- self$stages[[stage_index]]$.cached_env
    if (is.null(env)) { cannot_run_error() }

    # Restart execution from cache, so set context to the cached environment.
    copy_env(self$.context, env)
    env
  }
}

#' Mark a given stage as being finished.
#' 
#' @param stage_index integer. The index of the substage in this stageRunner.
stageRunner_.mark_finished <- function(stage_index) {
  node <- treeSkeleton$new(self$stages[[stage_index]])$successor()

  if (!is.null(node)) { # Prepare a cache for the future!
    if (self$with_tracked_environment()) {
      # We assume the head for the tracked_environment is set correctly.
      package_function("objectdiff", "commit")(self$.context, node$object$index())
    } else {
      node$object$.cached_env <- new.env(parent = parent.env(self$.context))
      copy_env(node$object$.cached_env, self$.context)
    }
  } else {
    # TODO: Remove this hack used for printing
    root <- self$.root()
    root$.finished <- TRUE
  }
}

#' Determine the root of the stageRunner.
#'
#' @name stageRunner_.root
#' @return the root of the stageRunner
stageRunner_.root <- function() {
  treeSkeleton$new(self)$root()$object
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner-next_stage.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Stagerunners allow for the option to use a special mode called <code>&quot;next&quot;</code>. In
this mode, instead of executing by default from the beginning of the
stagerunner, execution will commence from the last non-executed stage.</p>

<p>This allows us to repeatedly call <code>runner$run()</code> until it has finished
executing, if errors occur during the process and we repeatedly fix them.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' For stageRunners with caching, find the next unexecuted stage.
#'
#' @name stageRunner_next_stage
#' @return a character stage key giving the next unexecuted stage.
#'   If all stages have been executed, this returns \code{FALSE}.
#'   If the stageRunner does not have caching enabled, this will
#'   always return the first stage key (`'1'`).
stageRunner_next_stage <- function() {
  for (stage_index in seq_along(self$stages)) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We use the <code>stageRunnerNode$was_executed</code> helper to determine if this
stage has been executed yet.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    is_unexecuted_terminal_node <- is.stageRunnerNode(self$stages[[stage_index]]) &&
      !self$stages[[stage_index]]$was_executed()
    if (is_unexecuted_terminal_node) return(as.character(stage_index))
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We can recursively use <code>next_stage</code> if the current stage is another
stagerunner rather than a terminal node.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    has_unexecuted_terminal_node <- is.stagerunner(self$stages[[stage_index]]) &&
      is.character(tmp <- self$stages[[stage_index]]$next_stage())

    if (has_unexecuted_terminal_node) return(paste(c(stage_index, tmp), collapse = '/'))
  }
  FALSE
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner-objectdiff.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Stagerunners remember the <em>full history</em> of their execution. If you have
fifty data preparation steps recorded in a stagerunner and the <code>remember</code>
flag is set to <code>TRUE</code>, a full copy of the dataset will be made after
each step. This is highly inefficient.</p>

<p>We attempt to solve this problem with a space-time tradeoff: the 
<a href="http://github.com/robertzk/objectdiff">objectdiff</a> package computes
the <em>difference</em> between the environment before and after executing
a given stage. By incorporating this package into a stagerunner,
we can take slightly more time (by computing differences between
environments during the execution of each stage) but save a lot
of memory (by only storing <em>patches</em> that record what has changed
during each step, rather than a full copy of the data set).</p>

<p>This advanced feature allows stagerunners to remain in-memory,
retaining the fast interactive iterate model building process.
The downside is either slightly more space or time usage depending
on the configuration of the objectdiff package.</p>

<p>We can avoid the problem entirely by doing all of our processing
in batches or in-database, but this is outside of the scope of
this package. For interactive model development on data sets
with less than 1M rows, performance is usually not prohibitive.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"># Some features of stageRunner, specifically its interaction with the
# objectdiff package, require some additional setup. We attempt to record
# all of these dependencies in this file.

#' Set all prefixes for child stageRunners.
#'
#' When a stageRunner is used in conjunction with an
#' \code{objectdiff::tracked_environment}, we need to remember
#' the full nested tree structure. This function sets up the
#' \code{prefix} member of each sub-stageRunner recursively to enable
#' correct remembering functionality.
#'
#' @param prefix character. The prefix to assign to this stageRunner.
#' @name stageRunner_.set_prefixes
stageRunner_.set_prefixes <- function(prefix = '') {
  self$.prefix <- prefix
  for (i in seq_along(self$stages)) {
    if (is.stageRunner(self$stages[[i]])) {
      self$stages[[i]]$.set_prefixes(paste0(prefix, i, '/'))
    }
  }
}

`first_commit?` <- function(commit) {
  all(strsplit(commit, "/", fixed = TRUE)[[1]] == '1')
}

</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner-overlay.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Overlaying a stagerunner means replacing the terminal nodes with
terminal nodes that do some extra behavior, and can themselves
be full stagerunners. This is subtly different than the <code>around</code>
method, which transforms the terminal node function itself, rather
than turning it from a function to a stagerunner.</p>

<p>For example, if we have a stagerunner like</p>

<ul>
<li>import data</li>
<li>clean data

<ul>
<li>impute variable 1</li>
<li>discretize variable 2</li>
</ul></li>
<li>train model</li>
</ul>

<p>we may wish to replace each function with a &ldquo;hidden&rdquo; mini-runner
that runs some tests after each stage.</p>

<ul>
<li>import data

<ul>
<li>vanilla function</li>
<li>some testing function that checks data got imported</li>
</ul></li>
<li>clean data

<ul>
<li>impute variable 1

<ul>
<li>vanilla function</li>
<li>some testing function that checks variables were imputed</li>
</ul></li>
<li>discretize variable 2

<ul>
<li>vanilla function</li>
<li>some testing function that checks variables were discretized</li>
</ul></li>
</ul></li>
<li>train model

<ul>
<li>vanilla function</li>
<li>some testing function that checks the model got trained successfully</li>
</ul></li>
</ul>

<p>We can achieve this by passing the stagerunner with the same tree structure
but containing tests in the terminal node as the argument to the main
stagerunner&#39;s <code>overlay</code> method.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Overlaying a stageRunner object is taking another stageRunner object
#' with similar stage names and adding the latter's stages as terminal stages
#' to the former (for example, to support tests).
#'
#' @name stageRunner_overlay
#' @param other_runner stageRunner. Another stageRunner from which to overlay.
#' @param label character. The label for the overlayed stageRunner. This refers
#'    to the name the former will get wrapped with when appended to the
#'    stages of the current stageRunner. For example, if \code{label = 'test'},
#'    and a current terminal node is unnamed, it will becomes
#'    \code{list(current_node, test = other_runner_node)}.
#' @param flat logical. Whether to use the \code{stageRunner$append} method to
#'    overlay, or simply overwrite the given \code{label}. If \code{flat = TRUE},
#'    you must supply a \code{label}. The default is \code{flat = FALSE}.
stageRunner_overlay <- function(other_runner, label = NULL, flat = FALSE) {
  stopifnot(is.stagerunner(other_runner))
  for (stage_index in seq_along(other_runner$stages)) {
    name <- names(other_runner$stages)[[stage_index]]
    index <-
      if (identical(name, '') || identical(name, NULL)) stage_index
      else if (name %in% names(self$stages)) name
      else stop('Cannot overlay because keys do not match')
    self$stages[[index]]$overlay(other_runner$stages[[stage_index]], label, flat)
  }
  TRUE
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner-package.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' stagerunner: in-memory reproducible data preparation and modeling
#'
#' stagerunner is an attempt to define a notion of data munging that includes
#' \emph{history}. By writing your code as a stagerunner instead of a
#' collection of functions, three key advantages should become clear:
#'
#' \itemize{
#' \item Clarity will emerge in code that is intended to execute a sequence
#'   of operations that aims to produce a final result.
#' \item Reproducibility of interactive munging steps is possible without
#'   re-executing your analysis from scratch.
#' \item Modularity and extensibility becomes free of charge: methods like
#'   \code{around} and \code{transform} allow you to apply the same operation
#'   to your entire modeling procedure, simplifying progress monitoring and
#'   debugging.
#' }
#'
#' Although originally intended for clarifying the modeling process,
#' stagerunners have much more general applicability. To learn more,
#' begin with the vignettes: \code{browseVignettes(package = "stagerunner")}.
#'
#' @docType package
#' @name stagerunner
#' @import crayon R6
#' @author Robert Krzyzanowski <\url{http://syberia.io}>
#' @seealso The core function in this package: \code{\link{stagerunner}}. It
#'   defines the constructor creating stagerunner objects that allow you to
#'   wrap a complicated modeling procedure into an organized hierarchy.
#' @references Full documentation and demos: \url{http://robertzk.github.io/stagerunner/};
#'   FAQ's: \url{http://robertzk.github.io/stagerunner/faq/}
NULL
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Since <code>self</code> is used all over the place in R6 method definitions, 
<code>R CMD CHECK</code> will yell at us if we do not include the line below.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">globalVariables('self')</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner-run.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>The heart of a stagerunner object is its <code>run</code> method, depicted on the
right. A stagerunner consists of two things:</p>

<ul>
<li><p><strong>a context</strong>: This is an <a href="http://adv-r.had.co.nz/Environments.html">environment</a> object
that allows the user to persistently store information between stages.
The usual way to build a data pipeline is to provide functions with
various inputs and hook them up to functions with various outputs.</p>

<p>This is nice because it is clear what the inputs and outputs will be.
However, the disadvantage is that hooking up all the functions can
become pretty messy.</p>

<p>In this approach, we let the user set their own
conventions for what to place in the context. The advantage is that
<em>all stages have the same form</em>, a function taking one argument (the 
context), and so they become easy to manipulate.</p></li>
<li><p><strong>stages</strong>: A list of functions or, recursively, other stagerunners. Each function
should take precisely one argument: the <em>context</em> described above.
If you have some familiarity with pure mathematics, you will know the
<a href="http://en.wikipedia.org/wiki/Group_action">original inspiration</a> for stagerunners:
a stagerunner is a sequence of actions on an environment.</p></li>
</ul>

<p><em>Running</em> a portion of a stagerunner means to execute some of its stages on 
its context. For example, suppose we start with an empty environment
<code>context = new.env()</code> and the following stages:</p>

<pre><code class="r">context &lt;- new.env()
runner  &lt;- stagerunner(context, list(
 &quot;Set x&quot;    = function(e) { e$x &lt;- 1 },
 &quot;Double x&quot; = function(e) { e$x &lt;- 2 * e$x }
))
</code></pre>

<p>If we write <code>runner$run(&quot;Set x&quot;)</code>, then <code>context$x</code> will become <code>1</code>.
If we write <code>runner$run(2)</code> (a syntactical shortcut), then <code>context$x</code>
becomes <code>2</code>. If we write <code>runner$run(2)</code> again, it will become <code>4</code>.</p>

<p>The real advantage of this approach becomes clear when we enable the <code>remember</code>
flag:</p>

<pre><code class="r">context &lt;- new.env()
runner  &lt;- stagerunner(remember = TRUE, context, list(
  &quot;Import data&quot;               = function(e) e$data &lt;- iris,
  &quot;Create dependent variable&quot; = function(e) e$dep_var &lt;- e$data[[1]] &gt; 5,
  &quot;Create derived variable&quot;   = function(e) e$diff &lt;- e$data[[1]] - e$data[[2]]
))
</code></pre>

<p>Now, the stagerunner holds a copy of the full environment in each stage:
this means we can re-run previous stages at will.</p>

<pre><code class="r">runner$run()        # Run all stages
runner$data &lt;- NULL # Clear the data
runner$run(2)       # Re-run just the second stage.
</code></pre>

<p>In this scenario, the <code>data</code> gets restored from a cached environment&ndash;
what the context looked like after the first stage finished&ndash;
and we have a <code>dep_var</code> column (although no <code>diff</code> column since
the third stage was now &ldquo;rolled back&rdquo;).</p>

<p>This kind of approach also allows us to debug what happens during execution:</p>

<pre><code class="r">envs &lt;- runner$run(2)
ls(envs$before$data) # The iris attributes
ls(envs$after$data)  # The iris attributes *and* dep_var
</code></pre>

<p>When a stagerunner is set to remember its progress the output of the <code>run</code>
function consists of a list with keys <code>before</code> and <code>after</code> representing
two environments: what the stagerunner&#39;s context looked like before
and after executing that stage.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Run the stages in a stageRunner object.
#'
#' @param from an indexing parameter. Many forms are accepted, but the
#'   easiest is the name of the stage. For example, if we have
#'   \code{stageRunner$new(context, list(stage_one = some_fn, stage_two = some_other_fn))}
#'   then using \code{run('stage_one')} will execute \code{some_fn}.
#'   Additional indexing forms are logical (which stages to execute),
#'   numeric (which stages to execute by indices), negative (all but the
#'   given stages), character (as above), and nested forms of these.
#'   The latter refers to instances of the following:
#'   \code{stageRunner$new(context, list(stage_one =
#'     stageRunner$new(context, substage_one = some_fn, substage_two = other_fn),
#'     stage_two = another_fn))}.
#'   Here, the following all execute only substage_two:
#'   \code{run(list(list(FALSE, TRUE), FALSE))},
#'   \code{run(list(list(1, 2)))},
#'   \code{run('stage_one/substage_two')},
#'   \code{run('one/two')},
#'   Notice that substrings are allowed for characters.
#'   The default is \code{NULL}, which runs the whole sequences of stages.
#' @param to an indexing parameter. If \code{from} refers to a single stage,
#'   attempt to run from that stage to this stage (or, if this one comes first,
#'   this stage to that stage). For example, if we have
#'      \code{stages = list(a = list(b = 1, c = 2), d = 3, e = list(f = 4, g = 5))}
#'   where the numbers are some functions, and we call \code{run} with
#'   \code{from = 'a/c'} and \code{to = 'e/f'}, then we would execute
#'   stages \code{"a/c", "d", "e/f"}.
#' @param verbose logical. Whether or not to display pretty colored text
#'   informing about stage progress.
#'   nested list of logicals.
#' @param remember_flag logical. An internal argument used by \code{run}
#'   recursively if the \code{stageRunner} object has the \code{remember}
#'   field set to \code{TRUE}. If \code{remember_flag} is FALSE, \code{run}
#'   will not attempt to restore the context from cache (e.g., if we are
#'   executing five stages simultaneously with \code{remember = TRUE},
#'   the first stage's context should be restored from cache but none
#'   of the remaining stages should).
#' @param mode character. If \code{mode = 'head'}, then by default the
#'   \code{from} parameter will be used to execute that stage and that
#'   stage only. If \code{mode = 'next'}, then the \code{from} parameter
#'   will be used to run (by default, if \code{to} is left missing)
#'   from the last successfully executed stage to the stage given by
#'   \code{from}. If \code{from} occurs before the last successfully
#'   executed stage (say S), the stages will be run from \code{from} to S.
#' @param normalized logical. A convenience recursion performance helper. If
#'   \code{TRUE}, stageRunner will assume the \code{from} argument is a
#'   nested list of logicals.</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Do not worry about this parameter, <code>.depth</code>.
It is used internally to keep track of how &ldquo;deep&rdquo; the current stage execution is.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' @param .depth integer. Internal parameter for keeping track of nested
#'   execution depth.
#' @param ... Any additional arguments to delegate to the \code{stageRunnerNode}
#'   object that will execute its own \code{run} method.
#'   (See \code{stageRunnerNode$run})
#' @return TRUE or FALSE according as running the stages specified by the
#'   \code{from} and \code{to} keys succeeded or failed. If
#'   \code{remember = TRUE}, this will instead be a list of the environment
#'   before and after executing the aforementioned stages. (This allows
#'   comparing what changes were made to the \code{context} during the
#'   execution of the stageRunner.)
#' @examples
#' env <- new.env()
#' some_fn    <- function(e) e$x <- 1
#' other_fn   <- function(e) e$y <- 1
#' another_fn <- function(e) e$z <- 1
#' sr <- stagerunner(env, list(stage_one =
#'  stagerunner(env, list(substage_one = some_fn, substage_two = other_fn)),
#'  stage_two = another_fn))
#' 
#' # Here, the following all execute only substage_two:
#'
#' sr$run(list(list(FALSE, TRUE), FALSE))
#' sr$run(list(list(1, 2)))
#' sr$run('stage_one/substage_two')
#' sr$run('one/two')
#' stopifnot(is.null(env$z), is.null(env$x), identical(env$y, 1))
#'
#' # This will execute all but "stage_one" (i.e., only "stage_two")
#' sr$run(-1)
#' stopifnot(identical(env$z, 1))
run <- function(from = NULL, to = NULL, verbose = FALSE,
                remember_flag = getOption("stagerunner.remember", TRUE),
                mode = self$.mode, normalized = FALSE, .depth = 1, ...) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>The parameter <code>normalized</code> refers to whether the input (that is, the <code>from</code>
and <code>to</code> parameters) are in the canonical nested list format. For example,
if we have a runner with stages &ldquo;Import&rdquo;, &ldquo;Data/impute&rdquo;, and
&ldquo;Data/discretize&rdquo;, the canonical representation for the first substage
of the second stage would be <code>list(FALSE, list(TRUE, FALSE))</code>. This allows
the stagerunner package to easily tell what is being executed.</p>

<p>If the <code>from</code> and <code>to</code> parameters are not in normal form, or the <code>from</code>
parameter is missing and the <code>to</code> parameter is present (so that we
are asking to run from the beginning to the stage denoted by <code>to</code>),
we must first normalize the keys to use this nested list format.</p>

<p>We will use the <code>stage_key</code> local variable to track what substages
to execute during this <code>run</code> call.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  if (identical(normalized, FALSE)) {
    if (missing(from) && identical(self$remember, TRUE) && identical(mode, 'next')) {
      from <- self$next_stage()
      if (missing(to)) to <- TRUE
    }
    stage_key <- normalize_stage_keys(from, self$stages, to = to)
  } else {
    stage_key <- from
  }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Now that we have determined which stages to run, we cycle through them all.
It is up to the user to determine that context changes make sense.
We also implicitly sort the stages to ensure linearity is preserved.
Stagerunner enforces the linearity and directionality set in the stage
definitions.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  </span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>If we are remembering changes, we must recall what the environment looked
like <em>before</em> we ran anything.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  before_env <- NULL

  for (stage_index in seq_along(stage_key)) {
    nested_run <- TRUE
    </span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>In a stagerunner, recursively nested stages (i.e., stages with substages)
are themselves represented as stagerunners, while final stages
(i.e., the functions to execute) are represented as <a href="http://cran.r-project.org/web/packages/R6/index.html">R6</a>
objects called <code>stageRunnerNode</code>s. In each scenario, a different
recursive call to <code>$run</code> will be necessary, so we compute a 
closure that gives the correct call for later use.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    run_stage <- determine_run_stage(stage_key, stage_index,
                                     self$stages, verbose, .depth)
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We keep track of whether this is a nested run so that the verbose
display knows whether to say &ldquo;<em>Beginning</em> stage X&rdquo; or &ldquo;<em>Running</em> stage X&rdquo;.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    if (isTRUE(stage_key[[stage_index]]) &&
        !is.stagerunner(self$stages[[stage_index]])) {
      nested_run <- FALSE
    }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>The above helper <code>run_stage</code> will return an object of class <code>next_stage</code>
if we should skip this stage (i.e., because <code>stage_key[[stage_index]]</code>
is <code>FALSE</code>).</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    if (is(run_stage, "next_stage")) next
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Display a nice message telling us which stage we are currently
executing.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    display_message <- isTRUE(verbose) && contains_true(stage_key[[stage_index]])
    if (display_message) {
      show_message(names(self$stages), stage_index, begin = TRUE,
                   nested = nested_run, depth = .depth)
    }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>If <code>remember = TRUE</code>, we have to cache the progress along each stage.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    if (self$remember && isTRUE(remember_flag) && is.null(before_env)) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>If we have not determined what the environment on the stagerunner
was like prior to running any stages, we do so now. This will
eventually be returned by this function, so that the user
can inspect what happened before and after all the desired
stages were executed.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">      if (nested_run) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>If this is a nested stage, we grab the &ldquo;initial environment&rdquo;
recursively.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">        before_env <- run_stage(..., remember_flag = TRUE)$before
      } else { </span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Otherwise, if it is a terminal node, we just make a copy of
the current context.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">        before_env <- self$.before_env(stage_index)
      }
      </span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>If the current stage is a terminal node,
execute the stage (if it was nested, it&#39;s already been
executed in order to recursively fetch the initial environment,
<code>before_env</code>).</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">      if (!nested_run) { run_stage(...) }
    }
    else if (self$remember) { run_stage(..., remember_flag = remember_flag) }
    else { run_stage(...) }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>When we&#39;re done running a stage (i.e., processing a terminal node),
set the cache on the successor node to be the current context
(since that node will execute starting with what&#39;s in the context now &ndash;
this also ensures that running that node with a separate call to
<code>$run</code> will not bump into a &ldquo;you haven&#39;t executed this stage yet&rdquo; error).</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    if (self$remember && isTRUE(remember_flag) && !nested_run) {
      self$.mark_finished(stage_index)
    }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Finally, display our progress by indicating we are ending this stage.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    if (display_message) {
      show_message(names(self$stages), stage_index, begin = FALSE,
                   nested = nested_run, depth = .depth)
    }
  }
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>If the stagerunner is a <em>remembering</em> stagerunner, i.e., the field
<code>remember = TRUE</code>, we will return a list with keys <code>before</code> and <code>after</code>
indicating what the stagerunner&#39;s context looked like before and after
executing the stages indicated by the <code>from</code> and <code>to</code> parameters.
This allows the user to perform their own analysis about what happened.</p>

<p>Otherwise, we simply return <code>TRUE</code> (<a href="http://stackoverflow.com/questions/11653127/what-does-the-function-invisible-do">invisibly</a>).</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  if (self$remember && isTRUE(remember_flag)) {
    list(before = before_env, after = self$.context)
  } else {
    invisible(TRUE)
  }
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>This is a helper function to call <code>$run</code> correctly if we are recursively
executing substages:</p>

<ul>
<li>If the substage is a stagerunner, pass along information about how
deep we currently are in the stagerunner for verbose printing.</li>
<li>Otherwise, simply call the <code>stageRunnerNode$run</code> method directly.</li>
</ul>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">determine_run_stage <- function(stage_key, stage_index, stages, verbose, .depth) {
  if (isTRUE(stage_key[[stage_index]])) {
    stage <- stages[[stage_index]]
    if (is.stagerunner(stage)) { 
      function(...) { stage$run(verbose = verbose, .depth = .depth + 1, ...) }
    } else {
     nested_run <- FALSE</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Intercept the <code>remember_flag</code> argument to calls to the <code>stageRunnerNode</code>
(since it doesn&#39;t know how to use it).</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">     function(..., remember_flag = TRUE) { stage$run(...) }
    }
  } else if (is.list(stage_key[[stage_index]])) {
    function(...) {
      stages[[stage_index]]$run(stage_key[[stage_index]], normalized = TRUE,
                                verbose = verbose, .depth = .depth + 1, ...)
    }
  } else {
    structure(list(), class = "next_stage")
  }
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner-show.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Printing a stagerunner should show information about:</p>

<ol>
<li>The hierarchical structure of its stages.</li>
<li>A summary of what stages have been already executed.</li>
</ol>

<p>We choose the following notation:</p>

<pre><code>A caching stageRunner with 4 stages:
+ import
 * data
   + impute variable
  * discretize variable
 - train model
Context &lt;environment: 0x101726640&gt;
</code></pre>

<p>The <code>+</code> indicates the stage has been executed successfully; <code>*</code> indicates
it is currently being executed; and <code>-</code> means the stage has not yet
been executed. If <code>remember = FALSE</code>, this information is not available,
so we only use this prefix notation for &ldquo;caching stagerunners&rdquo; (those
with <code>remember = TRUE</code>).</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Generic for printing stageRunner objects.
#' 
#' @name stageRunner_show
#' @param indent integer. Internal parameter for keeping track of nested
#'   indentation level.
stageRunner_show <- function(indent = 0) {
  if (missing(indent)) {
    sum_stages <- function(x) sum(vapply(x,
      function(x) if (is.stagerunner(x)) sum_stages(x$stages) else 1L, integer(1)))
    caching <- if (self$remember) " caching"
    cat("A", caching, " stageRunner with ",
        sum_stages(self$stages), " stages:\n", sep = '')
  }

  stage_names <- names(self$stages) %||% rep("", length(self$stages))

  for (index in seq_along(stage_names)) {
    prefix <- paste0(rep('  ', (if (is.numeric(indent)) indent else 0) + 1), collapse = '')
    currently_executing_this_stage <- self$remember && began_stage(self$stages[[index]])

    if (currently_executing_this_stage) {
      next_stage <- treeSkeleton$new(self$stages[[index]])$last_leaf()$successor()$object
      if (( is.null(next_stage) && !self$.root()$.finished) ||
          (!is.null(next_stage) && !began_stage(next_stage)))
        marker <- '*' # Use a * if this is the next stage to be executed
        # TODO: Fix the bug where we are unable to tell if the last stage
        # finished without a .finished internal field.
        # We need to look at and set predecessors, not successors.
      else {
       marker <- '+' # Other use a + for completely executed stage
      }
    } else {
      marker <- '-'
    }

    prefix <- gsub('.$', marker, prefix)
    if (is.na(stage_names[[index]]) || stage_names[[index]] == "") {
      stage_name <- paste0("< Unnamed (stage ", index, ") >")
    } else {
      stage_name <- stage_names[[index]]
    }

    cat(prefix, stage_name, "\n")

    if (is.stagerunner(self$stages[[index]])) {
      self$stages[[index]]$show(indent = indent + 1)
    }
  }

  if (missing(indent)) {
    cat('Context ')
    print(self$.context)
  }

  NULL
}

# A helper function for determining if a stage has been run yet.
began_stage <- function(stage) {
  if (is.stagerunner(stage)) {
    any(vapply(stage$stages, began_stage, logical(1)))
  } else if (is.stageRunnerNode(stage)) {
    node <- treeSkeleton(stage)$predecessor()$object
    is.null(node) || node$executed
  }
}

#' @export
print.stageRunner <- function(x, ...) {
  x$show(...)
}

#' @export
print.stageRunnerNode <- function(x, ...) {
  x$show(...)
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner-stage_names.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Retrieve a flattened list of canonical stage names for a stageRunner object
#'
#' For example, if we have stages
#'   \code{stages = list(a = list(b = 1, c = 2), d = 3, e = list(f = 4, g = 5))}
#' then this method would return
#'   \code{list('a/b', 'a/c', 'd', 'e/f', 'e/g')}
#'
#' @name stageRunner_stage_names
#' @return a list of canonical stage names.
# # @examples
# # f <- function() {}
# # sr <- stageRunner$new(new.env(),
# #   list(a = stageRunner$new(new.env(), list(b = f, c = f)), d = f,
# #   e = stageRunner$new(new.env(), list(f = f, g = f))))
# # sr$stage_names()
stageRunner_stage_names <- function() {
  nested_stages <- function(x) {
    if (is.stagerunner(x)) {
      lapply(x$stages, nested_stages)
    } else {
      x
    }
  }

  nested_names(lapply(self$stages, nested_stages))
}

#' Delimited names of a nested list.
#'
#' Unnamed values will use index number instead.
#'
#' @name nested_names
#' @param el list.
#' @param delim character. The delimiter with which to separate nested names.
#' @param prefix character. A prefix to every name.
#' @return a list of nested names
#' @examples
#' stagerunner:::nested_names(list(a = list(b = 1, c = list(d = 2, e = 3)), f = 4, 5))
#' # c('a/b', 'a/c/d', 'a/c/e', 'f', '3')
#' stagerunner:::nested_names(list(a = list(b = 1, c = 2), d = 2), delim = ' ', prefix = '#')
#' # c('#a b', '#a c', '#d')
nested_names <- function(el, delim = '/', prefix = '') {
  list_names <- names(el) %||% rep("", length(el))
  Reduce(c, lapply(seq_along(el), function(index) {
    name <- if (list_names[[index]] == "") as.character(index)
            else list_names[[index]]
    paste0(prefix,
      if (is.list(el[[index]])) {
        paste0(name, delim, nested_names(el[[index]], delim = delim, prefix = ''))
      } else name)
  }))
}</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner-transform.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Straightforwardly, apply some function (<code>transformation</code>)
to every terminal node in the stagerunner. This is useful for
simple debugging and monitoring. For example, if we wish to 
print the variables currently in the context of stagerunner
prior to executing each stage, we can call</p>

<pre><code class="r">runner$transform(function(fn) {
  function(context, ...) {
    print(ls(context))
    fn(context, ...)
  }
})
</code></pre>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Transform the callable's of the terminal nodes of a stageRunner.
#'
#' Every terminal node in a stageRunner is of type stageRunnerNode.
#' These each have a callable, and this method transforms those
#' callables in the way given by the first argument.
#'
#' @name stageRunner_transform
#' @param transformation function. The function which transforms one callable
#'   into another.
stageRunner_transform <- function(transformation) {
  for (stage_index in seq_along(self$stages)) {
    self$stages[[stage_index]]$transform(transformation)
  }
  self
}

</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stagerunner.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' @include stagerunner-initialize.R stagerunner-run.R stagerunner-around.R
#'   stagerunner-coalesce.R stagerunner-overlay.R stagerunner-transform.R
#'   stagerunner-append.R stagerunner-stage_names.R stagerunner-current_stage.R
#'   stagerunner-next_stage.R stagerunner-show.R stagerunner-has_key.R
#'   stagerunner-internal.R
#'   stageRunnerNode.R
NULL
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We use <a href="https://github.com/wch/R6">R6</a> instead of the built-in 
<a href="https://stat.ethz.ch/R-manual/R-devel/library/methods/html/refClass.html">reference classes</a> 
for several reasons.</p>

<ol>
<li>Their definition is much more compact.</li>
<li>It is possible to extend R6 definitions cross-packages.</li>
<li>They suppor the notion of public and private membership.</li>
</ol>

<p>A stagerunner is clearly represented as a reference object, rather than an
S3 or S4 class, as it is by nature highly mutable: every stage execution
triggers updates of the corresponding stage caches.</p>

<p>A stagerunner is primarly defined by its <strong>context</strong> and its <strong>stages</strong>.
The former is an environment (or when used in conjunction with
<a href="https://github.com/robertzk/objectdiff">objectdiff</a>, a 
\code{\link[objectdiff]{tracked_environment}}
that holds the current state of the stagerunner.</p>

<p>A stagerunner&#39;s stages are a nested list of either <code>stageRunnerNode</code>s
(wrappers for functions) or more stagerunners, the latter if we wish to
group together logically bound collections of functions (like a data
preparation procedure or a sequence of modeling steps).</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Stagerunners are parametrized sequences of linear execution.
#' 
#' @name stageRunner
#' @format NULL
#' @docType class
stageRunner_ <- R6::R6Class('stageRunner',
  active = list(context = function() self$.context),                            
  public = list(
    .context = NULL,
    stages = list(),
    remember = FALSE,
    .mode = "head",
    .parent = NULL,
    .finished = FALSE,
    .prefix = "",
    initialize     = stagerunner_initialize,
    run            = run,
    around         = stageRunner_around,
    coalesce       = stageRunner_coalesce,
    overlay        = stageRunner_overlay,
    transform      = stageRunner_transform,
    append         = stageRunner_append,
    stage_names    = stageRunner_stage_names,
    parent         = function() { self$.parent },
    children       = function() { self$stages },
    current_stage  = stageRunner_current_stage,
    next_stage     = stageRunner_next_stage,
    show           = stageRunner_show,
    has_key        = stageRunner_has_key,
    mode           = function() { self$mode },
    .set_parents   = stageRunner_.set_parents,
    .clear_cache   = stageRunner_.clear_cache,
    .root          = stageRunner_.root,

    # objectdiff intertwined functionality
    .set_prefixes  = stageRunner_.set_prefixes,
    .before_env    = stageRunner_.before_env,
    .mark_finished = stageRunner_.mark_finished,
    with_tracked_environment = function() {
      out <- is(self$context, 'tracked_environment')
      if (out) { requireNamespace("objectdiff", quietly = TRUE) }
      out
    }
  )
)
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>A little trick to ensure that a stagerunner can be constructed both as
<code>stagerunner(...) and stagerunner$new(...)</code>.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' @rdname stageRunner
#' @param ... Arguments to pass to stagerunner initialization.
#' @export
stageRunner <- structure(
  function(...) { stageRunner_$new(...) },
  class = "stageRunner_"
)

#' @export
#' @rdname stageRunner
stagerunner <- stageRunner
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>To make the above trick work, we need to prevent access to everything except
<code>new</code>.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' @export
`$.stageRunner_` <- function(...) {
  stopifnot(identical(..2, "new"))
  ..1
}

#' Check whether an R object is a stageRunner object
#'
#' @export
#' @param obj any object.
#' @return \code{TRUE} if the object is of class
#'    \code{stageRunner}, \code{FALSE} otherwise.
is.stagerunner <- function(obj) inherits(obj, 'stageRunner')
#' @rdname is.stagerunner
#' @export
is.stageRunner <- is.stagerunner
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stageRunnerNode-around.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Wrap a stageRunnerNode callable with another callable.
#'
#' @param other_node stagerunner or stageRunnerNode.
#' @return \code{TRUE} or \code{FALSE} according as the wrapping was
#'    successful.
#' @examples \dontrun{
#' node1 <- stageRunnerNode(function(e) print(2))
#' node2 <- stageRunnerNode(function(e) { print(1); yield(); print(3); })
#' node1$around(node2)
#' node1$run() # Will print 1 2 3
#' # Notice the provided "yield" keyword, which allows calling the
#' # node that is being wrapped.
#' }
stageRunnerNode_around <- function(other_node) {
  if (is.stageRunnerNode(other_node)) {
    other_node <- other_node$callable
  }

  if (is.null(other_node)) {
    return(FALSE)
  }

  if (!is.function(other_node)) {
    warning("Cannot apply stageRunner$around in a terminal ",
            "node except with a function. Instead, I got a ",
            class(other_node)[1])
    return(FALSE)
  }

  new_callable <- other_node
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We inject the <code>yield</code> keyword.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  environment(new_callable) <- list2env(parent = environment(new_callable), list(
    .parent_context = self,
    yield           = around_yield(self$callable)
  ))
  self$callable <- new_callable
  TRUE
}

around_yield <- function(callable) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Constructing the yield keyword is a little bit messy. We want to pass
the exact same parameters as the call to the original callable, so
can grab <code>...</code> from two frames up. However, since we must also
provide the function we are invoking with <code>yield</code> (i.e., the <code>callable)</code>,
we have in effect two different kinds of injections.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  yield <- function() {
    # ... lives up two frames, but the run function lives up 1,
    # so we have to do something ugly
    run <- eval.parent(quote(.parent_context$run))
    args <- append(eval.parent(quote(list(...)), n = 2),
      list(.callable = callable))
    do.call(run, args, envir = parent.frame())
  }</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We don&#39;t need anything except the base environment for the body of
the <code>yield</code> keyword itself.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  environment(yield) <- list2env(list(callable = callable), parent = baseenv())
  yield
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stageRunnerNode-overlay.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Consider the following runner.</p>

<ol>
<li>Import data.</li>
<li>Munge data.</li>
<li>Create model.</li>
<li>Export model.</li>
</ol>

<p>Imagine we wish to add some assertions at the end of each stage,
like ensuring that data was in fact imported and that munging performed
some necessary operations.</p>

<p>We can replace each function in the above four stages with a 
stageRunner consisting of the original function and a new &ldquo;assertion&rdquo;
function. This is precisely the job of the <code>around</code> method on
<code>stageRunnerNode</code>s.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Append one stageRunnerNode around another.
#'
#' @param other_node stagerunner or stageRunnerNode.
#' @param label character. Under the hood, this will be the "stage name"
#'    for the stage represented by the \code{other_node} in the
#'    automatically generated new stageRunner used as this node's
#'    callable (assuming \code{flat} is \code{FALSE}).
#' @param flat logical. If \code{TRUE}.
#' @return \code{TRUE} or \code{FALSE} according as the wrapping was
#'    successful.
#' @examples \dontrun{
#' node1 <- stageRunnerNode(function(e) print(1))
#' node2 <- stageRunnerNode(function(e) print(2))
#' node1$overlay(node2)
#' node1$run() # Will print 1 2
#' }
stageRunnerNode_overlay <- function(other_node, label = NULL, flat = FALSE) {
  if (is.stageRunnerNode(other_node)) {
    other_node <- other_node$callable
  }

  if (is.null(other_node)) { 
    return(FALSE)
  }

  if (!is.stagerunner(other_node)) {
    other_node <- stageRunner$new(self$.context, other_node)
  }

  # Coerce the current callable object to a stageRunner so that
  # we can append the other_node's stageRunner.
  if (!is.stagerunner(self$callable)) {
    self$callable <- stageRunner$new(self$.context, self$callable)
  }

  # TODO: Fancier merging here
  if (isTRUE(flat)) {
    if (!is.character(label)) stop("flat coalescing needs a label")
    self$callable$stages[[label]] <- other_node
  } else {
    self$callable$append(other_node, label)
  }
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stageRunnerNode-run.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Execute the callable of a stageRunnerNode.
#'
#' @param ... additional arguments to the \code{callable}. This allows,
#'    stagerunner stages to be uniformly parametrized (for example,
#'    if all stages should have a \code{verbose} parameter.
#' @param .cached_env An internal helper that passes the cached environment
#'    to be used for storing the results of this execution.
#' @param .callable Another internal helper used for some recursive
#'    metaprogramming.
#' @return \code{TRUE} if the execution was successful, or an error otherwise.
stageRunnerNode_run <- function(..., .cached_env = NULL, .callable = self$callable) {
  # TODO: Clean this up by using environment injection utility fn
  correct_cache <- .cached_env %||% self$.cached_env
  if (is.null(.callable)) {
    FALSE
  } else if (is.stagerunner(.callable)) {
    .callable$run(..., .cached_env = correct_cache)
  } else {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>If we are executing a function, we inject the \code{cached_env}
into the environment for use by, e.g., testing functions. Ideally,
the callable should be able to determine what the state of the runner
looked like before execution.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    environment(.callable) <- list2env(
      list(cached_env = correct_cache), parent = environment(.callable)
    )</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>But once this function finishes executing, restore the environment of
the callable to its former glory (i.e., remove the <code>cached_env</code>).</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    on.exit(environment(.callable) <- parent.env(environment(.callable)))
    .callable(self$.context, ...)
  }
  self$executed <- TRUE
}

</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stageRunnerNode-transform.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>This helper method is useful when we want to apply some transformation
to <em>all</em> terminal nodes of a stageRunner. You can think of it as 
\code{\link{rapply}} for stageRunners.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Transform a stageRunnerNode according to a functional.
#'
#' @param transformation function. An arity-1 function which takes the
#'    \code{callable} of a \code{stageRunnerNode} and transforms it
#'    into another callable (i.e. a function or a stagerunner). If the
#'    original \code{callable} is a stagerunner, its terminal nodes in
#'    turn will be transformed recursively.
#' @return The transformed callable.
#' @examples \dontrun{
#' increment <- 1
#' adder     <- function(x) x + increment
#' node      <- stageRunnerNode$new(function(e) print(adder(1)))
#' node$transform(function(fn) {
#'   environment(fn)$increment <- environment(fn)$increment + 1; fn
#' })
#' node$run() # Prints 3, rather than 2
#' }
stageRunnerNode_transform <- function(transformation) {
  if (is.stagerunner(self$callable)) {
    self$callable$transform(transformation)
  } else {
    self$callable <- transformation(self$callable)
  }
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>stageRunnerNode.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>In order to give us more flexibility on the terminal nodes of a
stagerunner (the actual functions that will be executed on the
stagerunner&#39;s <code>context</code>), we wrap them in an R6 class called a
<code>[stageRunnerNode]</code>. This will be extremely useful if we wish to
dynamically allow our stagerunners to be extended or wrapped with
functionality.</p>

<p>For example, if we have a runner such as</p>

<ol>
<li>Import data.</li>
<li>Munge data.</li>
<li>Create model.</li>
<li>Export model.</li>
</ol>

<p>we might want to run tests for each stage. To do so, we can replace
each terminal node, a function, with a stagerunner consisting of
two functions. We can do this with the <code>overlay</code> helper method:</p>

<p><code>runner$overlay(test_runner)</code></p>

<p>Here, <code>test_runner</code> is another stagerunner with the exact same
structure as our main runner, but with testing functions in its
terminal nodes.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Stagerunner nodes are environment wrappers around individual stages
#' (i.e. functions) in order to track meta-data (e.g., for caching).
#' 
#' @name stageRunnerNode
#' @format NULL
#' @docType class
stageRunnerNode_ <- R6::R6Class('stageRunnerNode',
  public = list(
    callable = NULL,
    .cached_env = NULL,
    .context = NULL,
    .parent = NULL,
    executed = FALSE,
    initialize = function(.callable, .context = NULL) {
      stopifnot(is_any(.callable, c('stageRunner', 'function', 'NULL')))
      self$callable <- .callable
      self$.context <- .context
      self$executed <- FALSE
    },

    run          = stageRunnerNode_run,
    around       = stageRunnerNode_around,
    overlay      = stageRunnerNode_overlay,
    transform    = stageRunnerNode_transform,
    was_executed = function() { self$executed },
    parent       = function() { attr(self, "parent") },
    children     = function() list(),
    show         = function() { cat("A stageRunner node containing: \n"); print(self$callable) },

    # Functions which intertwine with the objectdiff package
    index        = function() {
      ix <- which(vapply(attr(self, "parent")$stages,
        function(x) identical(self, x), logical(1)))
      paste0(attr(self, "parent")$.prefix, ix)
    }
  )
)

#' @export
stageRunnerNode <- structure(
  function(...) { stageRunnerNode_$new(...) },
  class = "stageRunnerNode_"
)

#' @export
`$.stageRunnerNode_` <- function(...) {
  stopifnot(identical(..2, "new"))
  ..1
}

#' @param obj ANY. An object to test for class \code{stageRunnerNode}.
#' @export
#' @rdname stageRunnerNode
is.stageRunnerNode <- function(obj) inherits(obj, 'stageRunnerNode')
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>treeSkeleton-initialize.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Initialize a treeSkeleton object.
#'
#' treeSkeleton objects allow you to traverse a reference class object
#' as if it had a tree structure, merely by knowing how to call parent
#' or child nodes.
#'
#' @name treeSkeleton__initialize
#' @param object ANY. If a reference class object, then \code{parent_caller}
#'    and \code{children_caller} will refer to reference class methods.
#'    If an attribute on the object with names of \code{children_caller} and
#'    \code{parent_caller} exists, those will be used. Otherwise, the
#'    generic methods will be used.
#' @param parent_caller character. The name of the reference class method
#'    that returns the parent object, if the object was a node in a tree
#'    structure.
#' @param children_caller character. The name of the reference class method
#'    that returns the child objects, if the object was a node in a tree
#'    structure.
#' @return a treeSkeleton object.
treeSkeleton__initialize <- function(object, parent_caller = 'parent',
                                     children_caller = 'children') {
  stopifnot(!is.null(object))
  self$object  <- object
  self$.parent   <- uninitialized_field()
  self$.children <- uninitialized_field()

  # Make sure parent_caller and children_caller are methods of object
  if (inherits(object, "R6")) {
    stopifnot(all(c(parent_caller, children_caller) %in% ls(object)))
  }

  self$parent_caller   <- parent_caller
  self$children_caller <- children_caller
  NULL
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>treeSkeleton-parent_index.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Find the index of the current object in the children of its parent.
#' @name treeSkeleton__.parent_index
treeSkeleton__.parent_index <- function() {
  if (!is.null(ci <- attr(self$object, 'child_index'))) ci
  # Hack for accessing attribute modifications on a reference class object
  # See: http://stackoverflow.com/questions/22752021/why-is-r-capricious-in-its-use-of-attributes-on-reference-class-objects
  else if (inherits(self$object, 'refClass') && !inherits(self$object, 'R6') &&
           !is.null(ci <- attr(attr(self$object, '.xData')$.self, 'child_index'))) ci
  else # look through the parent's children and compare to .self
    # Danger Will Robinson! This will lead to strange bugs if our tree
    # has several nodes with duplicate objects
    which(vapply(
      self$parent()$children(),
      function(node) identical(node$object, self$object), logical(1)))[1]
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>treeSkeleton-predecessor.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Attempt to find the predecessor of the current node.
#'
#' @name treeSkeleton__predecessor
#' @param index integer. If specified, this is the index of the current node
#'   in the children of its parent. (Sometimes, this cannot be computed
#'   automatically, and should usually be provided.)
#' @return predecessor for the wrapped object.
treeSkeleton__predecessor<- function(index = NULL) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We define the predecessor of the root node as <code>NULL</code>.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  if (is.null(p <- self$parent())) return(NULL) 

  parent_index <- if (is.null(index)) self$.parent_index() else index
  stopifnot(is.finite(parent_index))
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>If we are the first leaf in the list of our parent&#39;s children,
our predecessor is our parent&#39;s successor</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  if (parent_index == 1) {
    p$predecessor()
  } else {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Otherwise, the predecessor is the last leaf of the previous child.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    p$children()[[parent_index - 1]]$last_leaf()
  }
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>treeSkeleton-successor.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            
          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Attempt to find the successor of the current node.
#'
#' @name treeSkeleton__successor
#' @param index integer. If specified, this is the index of the current node
#'   in the children of its parent. (Sometimes, this cannot be computed
#'   automatically, and should usually be provided.)
#' @return successor for the wrapped object.
treeSkeleton__successor <- function(index = NULL) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>We define the successor of the root node as <code>NULL</code>.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  if (is.null(p <- self$parent())) return(NULL) # no successor of root node

  parent_index <- if (is.null(index)) self$.parent_index() else index
  stopifnot(is.finite(parent_index))
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>If we are the last leaf in the list of our parent&#39;s children,
our successor is our parent&#39;s successor</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">  if (parent_index == length(p$children())) {
    p$successor()
  } else {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Otherwise, the successor is the first leaf of the next child node.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    p$children()[[parent_index + 1]]$first_leaf()
  }
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>treeSkeleton.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Stagerunners are <a href="https://en.wikipedia.org/wiki/Tree_(data_structure">tree structures</a>)
and come with a natural set of operations, like taking the predecessor,
successor, and root of a node. However, these are not entirely simple to
implement in a manner that is implementation-independent.</p>

<p>Specifically, we recognize that the notion of a node successor and
predecessor is implementation agnostic as long as we have access
to class methods that provide access to a node&#39;s parent and children.
In this case, we can write an implementation-agnostic version that
works regardless of whether the object is an S3, S4, or R6
object.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' @include treeSkeleton-initialize.R treeSkeleton-predecessor.R
#'    treeSkeleton-successor.R treeSkeleton-parent_index.R
NULL

#' Find the root node of the tree (the only one with no parent).
#'
#' @name treeSkeleton__root
#' @return The root node of the tree or NULL if empty tree.
treeSkeleton__root <- function() {
  if (is.null(self$parent())) self
  else self$parent()
}

#' Find the first leaf in a tree.
#'
#' @name treeSkeleton__first_leaf
#' @return The first leaf, that is, the first terminal child node.
treeSkeleton__first_leaf <- function() {
  if (length(self$children()) == 0) self
  else self$children()[[1]]$first_leaf()
}

#' Find the last leaf in a tree.
#'
#' @name treeSkeleton__last_leaf
#' @return The last leaf, that is, the last terminal child node.
treeSkeleton__last_leaf <- function() {
  if (length(childs <- self$children()) == 0) self
  else childs[[length(childs)]]$last_leaf()
}

#' Find the parent of the current object wrapped in a treeSkeleton.
#' @name treeSkeleton__parent
treeSkeleton__parent <- function() {
  if (!is.unitialized_field(self$.parent)) return(self$.parent)
  self$.parent <-
    if (is.null(obj <- OOP_type_independent_method(self$object, self$parent_caller))) NULL
    else treeSkeleton$new(obj, parent_caller = self$parent_caller,
                          children_caller = self$children_caller)
}

#' Find the children of the current object wrapped in treeSkeletons.
#' @name treeSkeleton__children
treeSkeleton__children <- function() {
  if (!is.unitialized_field(self$.children)) return(self$.children)
  prechildren <- OOP_type_independent_method(self$object, self$children_caller)
  self$.children <- lapply(prechildren, treeSkeleton$new,
                       parent_caller = self$parent_caller)
}

#' Find the key with the given index using the names of the lists
#' that parametrize each node's children.
#'
#' For example, if our tree structure is given by
#'   \code{list(a = list(b = 1, c = 2))}
#' then calling \code{find('a/b')} on the root node will return \code{1}.
#'
#' @name treeSkeleton__find
#' @param key character. The key to find in the given tree structure,
#'    whether nodes are named by their name in the \code{children()}
#'    list. Numeric indices can be used to refer to unnamed nodes.
#'    For example, if key is \code{a/2/b}, this method would try to find
#'    the current node's child \code{a}'s second child's \code{b} child.
#'    (Just look at the examples).
#' @return the subtree or terminal node with the given key.
#' @examples 
#' \dontrun{
#' sr <- stageRunner$new(new.env(), list(a = list(force, list(b = function(x) x + 1))))
#' stagerunner:::treeSkeleton$new(sr)$find('a/2/b') # function(x) x + 1
#' }
treeSkeleton__find <- function(key) {</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Currently out of service! Will be back shortly.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#  stopifnot(is.character(key))
#  if (length(key) == 0 || identical(key, '')) return(self$object)
#  # Extract "foo" from "foo/bar/baz"
#  subkey <- regmatches(key, regexec('^[^/]+', key))[[1]]
#  key_remainder <- substr(key, nchar(subkey) + 2, nchar(key))
#  if (grepl('^[0-9]+', subkey)) {
#    subkey <- as.integer(subkey)
#    key_falls_within_children <- length(self$children()) >= subkey
#    stopifnot(key_falls_within_children)
#  } else {
#    matches <- grepl(subkey, names(self$children()))
#    stopifnot(length(matches) == 1)
#    key <- which(matches)
#  }
#  self$children()[[key]]$find(key_remainder)
}

#' This class implements iterators for a tree-based structure
#' without an actual underlying tree.
#'
#' In other dynamic languages, this kind of behavior would be called
#' duck typing. Imagine we have an object \code{x} that is of some
#' reference class. This object has a tree structure, and each node
#' in the tree has a parent and children. However, the methods to
#' fetch a node's parent or its children may have arbitrary names.
#' These names are stored in \code{treeSkeleton}'s \code{parent_caller}
#' and \code{children_caller} fields. Thus, if \code{x$methods()}
#' refers to \code{x}'s children and \code{x$parent_method()} refers
#' to \code{x}'s parent, we could define a \code{treeSkeleton} for
#' \code{x} by writing \code{treeSkeleton$new(x, 'parent_method', 'methods')}.
#'
#' The iterators on a \code{treeSkeleton} use the standard definition of
#' successor, predecessor, ancestor, etc.
#'
#' @name treeSkeleton
#' @docType class
#' @format NULL
treeSkeleton_ <- R6::R6Class('treeSkeleton',
  public = list(
    object = 'ANY',</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>As long as we know how to get an objects parent and children,
we will be able to determine all the nice derived methods below.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">    parent_caller = 'character',
    children_caller = 'character',
    .children = 'ANY',
    .parent = 'ANY',

    initialize    = treeSkeleton__initialize,
    successor     = treeSkeleton__successor,
    predecessor   = treeSkeleton__predecessor,
    parent        = treeSkeleton__parent,
    children      = treeSkeleton__children,
    root          = treeSkeleton__root,
    first_leaf    = treeSkeleton__first_leaf,
    last_leaf     = treeSkeleton__last_leaf,
    find          = treeSkeleton__find,
    .parent_index = treeSkeleton__.parent_index,
    show          = function() { cat("treeSkeleton wrapping:\n"); print(self$object) }
  )
)
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Some fancy tricks to make <code>treeSkeleton(...)</code> and <code>treeSkeleton(...)</code>
have the same effect, just like in traditional reference classes.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' @export
treeSkeleton <- structure(
  function(...) { treeSkeleton_$new(...) },
  class = "treeSkeleton_"
)

#' @export
`$.treeSkeleton_` <- function(...) {
  stopifnot(identical(..2, "new"))
  ..1
}

uninitialized_field <- function() {
  structure(NULL, class = "uninitialized_field")
}

is.unitialized_field <- function(x) {
  is(x, "uninitialized_field")
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <h1>utils.R</h1>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer"></span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>A handy little trick from Hadley: this will return the second argument
if the first is <code>NULL</code>.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">`%||%` <- function(x, y) if (is.null(x)) y else x

contains_true <- function(x) {
  if (is.list(x)) any(vapply(x, contains_true, logical(1)))
  else any(x)
}

all_logical <- function(x) {
  is.logical(x) || all(vapply(x,
    function(y) if (is.atomic(y)) is.logical(y) else all_logical(y),
  logical(1)))
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>A helper function for printing stagerunner execution progress.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">as.ordinal <- function(number) {
  ordinals <- list('first', 'second', 'third', 'fourth', 'fifth',
    'sixth', 'seventh', 'eighth', 'ninth', 'tenth', 'eleventh',
    'twelfth', 'thirteenth', 'fourteenth', 'fifteenth',
    'sixteenth', 'seventeenth', 'eighteenth', 'nineteenth',
    'twentieth')
  ext <- c("th", "st", "nd", "rd", rep("th", 6))
  ordinals[number][[1]] %||%
  paste0(number, ext[[(number %% 10) + 1]])
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Print some nice messages that tell you what type the stagerunner
constructor expects.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">enforce_type <- function(value, expected, klass, name = deparse(substitute(value))) {
  if (missing(value)) {
    stop(sprintf(
      "Please provide %s%s.",
      articleize(sQuote(crayon::red(name))),
      if (missing(klass)) "" else paste( " to a", klass)
    ))
  }

  check <- utils::getFromNamespace(paste0("is.", expected), "base")
  if (!check(value)) {
    stop(sprintf(
      "Please pass %s as the %s%s; instead I got a %s.",
      articleize(sQuote(crayon::yellow(expected))), dQuote(name),
      if (missing(klass)) "" else paste(" for a", klass),
      crayon::red(sclass(value))
    ))
  }
}

sclass <- function(obj) { class(obj)[1L] }

articleize <- function(word) {
  sprintf("a%s %s", if (is_vowel(first_letter(word))) "n" else "", word)
}

is_vowel <- function(char) {
  is.element(char, c("a", "e", "i", "o", "u", "A", "E", "I", "O", "U"))
}

first_letter <- function(word) {
  substring(gsub("[^a-zA-Z]|\\[3[0-9]m", "", word), 1, 1)
}

# Whether obj is of any of the given types.
is_any <- function(obj, klasses) {
  any(vapply(klasses, inherits, logical(1), x = obj))
}

package_function <- function(pkg, fn) { # for when using :: breaks R CMD check
  get(fn, envir = getNamespace(pkg))
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p>Used in conjunction with <code>treeSkeleton</code> so that it works for S3, S4, RC,
and R6 classes.</p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">#' Call a method on an object regardless of its OOP type.
#'
#' @name OOP_type_independent_method 
#' @param object any. An R object of variable OOP type (S3, S4, RC, R6).
#' @param method character. The method to call on the \code{object}. If the
#'    latter is a reference class, it use the \code{$} operator to access the method.
#'    (For example, \code{object$some_method}). If it has an attribute with the name
#'    \code{method}, it will use that attribute as the method to call. Otherwise,
#'    it will try to fetch a generic with the name \code{method} using \code{get}.
OOP_type_independent_method <- function(object, method) {
  if (method %in% names(attributes(object))) {
    attr(object, method)
  } else if (is.environment(object) && method %in% ls(object)) {
    object[[method]]()
  } else {
    get(method)(object)
  }
}
</span></code>
            </pre>
          </div>
        </div>
        <div class="section">
          <div class="markdown markdown-body">
            <p><a href="http://stackoverflow.com/questions/22675046/transforming-a-nested-environment-into-a-nested-list/22675108#22675108">Convert an environment to a list recursively.</a></p>

          </div>

          <div class="code">
            <pre>
              <code class="R"><span class="spacer">as.list.environment <- function(env) {
  out <- base::as.list.environment(env)
  lapply(out, function(x) if (is.environment(x)) as.list(x) else x)
}
</span></code>
            </pre>
          </div>
        </div>
      <div class="section">
      </div>

    </div>
  </body>
</html>
